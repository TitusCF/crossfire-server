/*
    Crossfire map browser generator.

    Author: Nicolas Weeger <nicolas.weeger@laposte.net>, (C) 2006, 2007, 2008.

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
*/

/**
 * @file mapper.c
 * This program generates map browsing web pages.
 *
 * Quick run: without arguments, will make sensible choices.
 *
 * For help, try the -help option.
 *
 * The following information is generated:
 * - a page per map
 * - a page per region
 * - a global map index
 * - the world map, including regions information
 * - the world map, with exits and blocking zones.
 *
 * Since this program browses maps from the first map, only maps linked from there will be processed.
 *
 * Maps are generated as the server sees them, that is with weather effects, treasures instead of markers,
 * and things like that.
 *
 * For maps, 2 pictures are generated, one real size and one small-size.
 *
 * Three maps are generated for the world: raw world map, world map with region information, region information only.
 *
 * Maps are always sorted, by the map name (part after the last /).
 *
 * Files are generated based on templates, where tags are replaced by their runtime value.
 *
 * Templates are recursively included. Here is the list:
 * - map.template: main map template.
 *  - map_no_exit.template: template to use when no exit on the map.
 *  - map_with_exit.template: template to use when there are exits on the map.
 *   - map_exit.template: template to use for each exit on the map.
 *  - map_lore: template to use to insert the map's lore.
 *  - map_no_lore: template when no lore for the map.
 * - region.template: region page template.
 *  - region_letter: template for one letter
 *   - region_map.template: one map in a region
 * - world.template: world map template
 *  - world_row.template: one row of world maps.
 *   - world_map.template: one map in the template.
 * - index.template: global map index.
 *  - index_letter.template: one letter in the index
 *   - index_map.template: one map in the whole index
 * - index_region.template: region index template.
 *  - index_region_region.template: one region in the index.
 *
 * Tags must be in the form #TAG#. To have a # in the code, please put ##. Valid tags are:
 *
 * - map:
 *  - NAME: map relative path
 *  - MAPPATH: full path to currently generated file.
 *  - MAPNAME: name of the map (part of the path after last /).
 *  - MAPPIC: name of full-size pic of the map.
 *  - MAPSMALLPIC: name of reduced-size pic of the map.
 *  - MAPEXIT: text generated by map_with_exit or map_no_exit.
 *  - INDEXPATH: path to index.html file.
 *  - REGIONPATH: path to region's file.
 *  - REGIONNAME: name of map's region.
 *  - REGIONINDEXPATH: path to region index file.
 *  - WORLDMAPPATH: path to world map file.
 *  - MAPLORE: map's lore.
 * - map_no_exit:
 *  - tags for map, except MAPEXIT.
 * - map_with_exit:
 *  - tags for map, except MAPEXIT.
 *  - EXIT: text generated by the map exits.
 * - map_exit:
 *  - map's tags.
 *  - EXITNAME: name of exit (part of the path after /).
 *  - EXITPATH: relative path of exit's page.
 * - map_lore:
 *  - tags for map, except MAPEXIT.
 *  - MAPLORE: map's lore.
 * - map_no_lore:
 *  - tags for map, except MAPEXIT.
 * - region:
 *  - MAPCOUNT: count of maps in region.
 *  - LETTERS: text generated by region_letter processing.
 * - region_letter:
 *  - region's tags, except LETTERS.
 *  - MAPNAME: name of the map (part of the path after last /).
 *  - MAPPATH: relative path of the map from the map's root.
 *  - MAPHTML: relative path of HTML file for map.
 * - region_map:
 *  - tags of region_letter.
 *  - MAPNAME: name of the map (part of the path after last /).
 *  - MAPPATH: relative path of the map from the map's root.
 *  - MAPHTML: relative path of HTML file for map.
 * - world:
 *  - MAPS: text generated by world_row processing.
 *  - WORLDMAP: path to world map picture, with regions information.
 *  - WORLDRAW: path to raw world map, without regions information.
 *  - WORLDREGIONS: path to world map picture containing only regions information.
 * - world_row:
 *  - MAPS: text generated by world_map processing.
 * - world_map:
 *  - MAPNAME: name of the map (part of the path after last /).
 *  - MAPPATH: relative path of the map's generated page.
 *  - MAPLEFT, MAPTOP, MAPRIGHT, MAPBOTTOM: coordinates (in pixels) of current map in full world map.
 * - index:
 *  - MAPCOUNT: count of maps.
 *  - LETTERS: text generated by index_letter processing.
 * - index_letter:
 *  - tags of index, except LETTERS.
 *  - MAPS: text generated by index_letter processing.
 *  - LETTER: letter being processed, uppercase.
 *  - LETTERCOUNT: number of maps for current letter.
 * - index_map:
 *  - tags of index_letter.
 *  - MAPNAME: name of the map (part of the path after last /).
 *  - MAPPATH: relative path of the map from the map's root.
 *  - MAPHTML: relative path of HTML file for map.
 * - index_region:
 *  - REGIONCOUNT: total number of regions.
 *  - REGIONS: text generated by index_region_region processing.
 * - index_region_region:
 *  - REGIONFILE: relative path to region page.
 *  - REGIONNAME: region name.
 *
 *
 * To build this program, from the utils directory:
 *  gcc mapper.c -I../include ../common/libcross.a -o mapper -lm -lgd
 */

#include <time.h>
#include <stdio.h>

#include <global.h>
#include <sproto.h>
#include <image.h>

#include <gd.h>
#include <gdfonts.h>
#include <gdfontl.h>
#include <gdfontg.h>

gdImagePtr* gdfaces;
extern int nrofpixmaps; /* Found in common/image.c */

typedef struct {
    struct struct_map_info** maps;
    int count;
    int allocated;
} struct_map_list;

typedef struct struct_map_info {
    char* path;
    char* name;
    char* filename;
    char* lore;
    struct_map_list exits_from;
    struct_map_list exits_to;
} struct_map_info;

/** Maps to process or found. */
struct_map_list maps_list;

/** Path to store generated files. Relative or absolute, shouldn't end with a / */
char root[500];
/** Number of created pictures for GD. */
int pics_allocated;

/* Options */
int generate_pics = 1;     /**< Whether to generate the picture or not. */
int force_pics = 0;        /**< To force picture regeneration even if map didn't change. */
int generate_index = 1;    /**< Whether to do the map index or not. */
int size_small = 16;       /**< Tile size for small map */
int map_limit = -1;        /**< Maximum number of maps to browse, -1 for all. */
int show_maps = 0;         /**< If set, will generate much information on map loaded. */
int world_map = 1;         /**< If set, will generate a world map. */

char* world_template;                 /**< World map template. */
char* world_row_template;             /**< One row in the world map. */
char* world_map_template;             /**< One map in a row. */

char* map_template;                 /**< Map template. */
char* map_no_exit_template;         /**< World map template: no exit. */
char* map_with_exit_template;       /**< Map template: exit template. */
char* map_exit_template;            /**< Map template: one exit. */
char* map_lore_template;            /**< Map template: lore. */
char* map_no_lore_template;         /**< Map template: no lore. */

char* index_template;           /**< Index page template. */
char* index_letter;             /**< Index page template: one letter, including the maps it contains. */
char* index_map;                /**< Index page template: one map. */

char* region_template;          /**< Region page template. */
char* region_letter_template;   /**< One letter for the region. */
char* region_map_template;      /**< Region page template: one map. */

char* index_region_template;
char* index_region_region_template;

/** Picture statistics. */
int created_pics = 0; /**< Total created pics. */
int cached_pics = 0;  /**< Non recrated pics. */

/** Map output formats. */
enum output_format_type {
    OF_PNG = 0,     /**< PNG, default value. */
    OF_JPG = 1      /**< JPG. */
};

/** Extensions depending on output format. */
const char* output_extensions[] = { ".png", ".jpg" };

/** Selected output format. */
enum output_format_type output_format = OF_PNG;

/** Quality for jpg pictures. */
int jpeg_quality = -1;

/** Whether to generate raw pics or instancied ones. */
int rawmaps = 0;

/** Whether to warn of exits without a path */
int warn_no_path = 0;

typedef struct maps_in_region {
    region* reg;
    /** Maps in the region. */
    struct_map_list maps_list;
    /** Sum of locations, to compute name position. */
    int sum_x, sum_y, sum;
    /** If set, this region has at least one map part of the world, thus region name should be written. */
    int is_world;
} maps_in_region;

struct maps_in_region** regions = NULL;
int region_count = 0;
int region_allocated = 0;

int list_unused_maps = 0;
char** found_maps = NULL;
int found_maps_count = 0;
int found_maps_allocated = 0;

/* Path/exit info */
gdImagePtr infomap;         /**< World map with exits / roads / blocking / ... */
int color_unlinked_exit;    /**< Color for exits without a path set. */
int color_linked_exit;      /**< Exit leading to another map. */
int color_road;             /**< Road or equivalent. */
int color_blocking;         /**< Block all movement. */
int color_slowing;          /**< Slows movement. */

/* Links between regions */
int do_regions_link = 0;
char** regions_link;
int regions_link_count = 0;
int regions_link_allocated = 0;

#define S_DOOR      0
#define S_KEY       1
#define S_CONTAINER 2
#define S_DETECTOR  3
#define S_CONNECT   4
#define S_MAX       5

/** slaying information. */
typedef struct {
    char* slaying;          /**< Slaying value. */
    struct_map_list maps[S_MAX];
} slaying_info_struct;

slaying_info_struct** slaying_info = NULL;  /**< Found slaying fields. */
int slaying_count = 0;                      /**< Count of items in slaying_info. */
int slaying_allocated = 0;                  /**< Allocated size of slaying_info. */

static void init_map_list(struct_map_list* list) {
    list->maps = NULL;
    list->count = 0;
    list->allocated = 0;
}

/**
 * Checks if ::object is considered a road or not.
 * @param item
 * ::object to check.
 * @return
 * 1 if object is a road, 0 else.
 */
static int is_road(object* item) {
    int test;
    /* Archetypes used as roads. */
    const char* roads[] = {
        "cobblestones",
        "flagstone",
        "ice_stone",
        "snow",
        NULL };
    const char* partial[] = {
        "dirtroad_",
        NULL };

    for (test = 0; partial[test] != NULL; test++) {
        if (strstr(item->arch->name, partial[test]) != NULL)
            return 1;
    }

    if (!QUERY_FLAG(item, FLAG_IS_FLOOR))
        return 0;

    for (test = 0; roads[test] != NULL; test++) {
        if (strcmp(item->arch->name, roads[test]) == 0)
            return 1;
    }

    return 0;
}

/**
 * Checks if item blocks movement or not.
 * @param item
 * ::object to test.
 * @return
 * 1 if item blocks all movement, 0 else.
 */
static int is_blocking(object* item) {
    return item->move_block == MOVE_ALL ? 1 : 0;
}

/**
 * Writes exit / road / blocking information for specified map.
 *
 * If map isn't a world map, won't do anything.
 *
 * @param map
 * map to write info for.
 */
void do_exit_map(mapstruct* map) {
    int tx, ty, x, y;
    object* item, *test;

    if (sscanf(map->path, "/world/world_%d_%d",&x,&y) != 2)
        return;

    x -= 100;
    y -= 100;

    for (tx = 0; tx < MAP_WIDTH(map); tx++) {
        for (ty = 0; ty < MAP_HEIGHT(map); ty++) {
            item = GET_MAP_OB(map, tx, ty);
            while (item) {
                test = item->head ? item->head : item;

                if (test->type == EXIT || test->type == TELEPORTER) {
                    if (!test->slaying)
                        gdImageSetPixel(infomap, x * 50 + tx, y * 50 + ty, color_unlinked_exit);
                    else
                        gdImageSetPixel(infomap, x * 50 + tx, y * 50 + ty, color_linked_exit);
                } else if (is_road(test))
                    gdImageSetPixel(infomap, x * 50 + tx, y * 50 + ty, color_road);
                else if (is_blocking(test)) {
                    gdImageSetPixel(infomap, x * 50 + tx, y * 50 + ty, color_blocking);
                    /* can't get on the spot, so no need to go on. */
                    break;
                } else if (test->move_slow != 0)
                    gdImageSetPixel(infomap, x * 50 + tx, y * 50 + ty, color_slowing);

                item = item->above;
            }
        }
    }
}

void do_auto_apply(mapstruct * m);

/**
 * Sort values alphabetically
 * Used by qsort to sort values alphabetically.
 * @param a
 * First value
 * @param b
 * Second value
 * @return
 * -1 if a is less than b, 0 if a equals b, 1 else.
 */
static int sortbyname(const void *a, const void *b){
    return (strcmp(*(const char**)a, *(const char**)b));
}

/**
 * Concatenates a string, and free concatenated string.
 *
 * @param source
 * string to append to. Can be NULL.
 * @param add
 * string that is appened. Will be free()d after. Must not be NULL.
 * @return
 * new string that should be free()d by caller.
 */
static char* cat_template(char* source, char* add) {
    if (!source)
        return add;
    source = realloc(source, strlen(source) + strlen(add) + 1);
    strcat(source, add);
    free(add);
    return source;
}

/**
 * Reads a file in memory.
 *
 * @param name
 * file path to read.
 * @param buffer
 * where to store. Can be left uninitialized in case of errors.
 * @note
 * will exit() with code 1 if any error occurs or if the file doesn't exist.
 */
static void read_template(const char* name, char** buffer) {
    FILE* file;
    struct stat info;

    if (stat(name, &info)) {
        printf("Couldn't stat template %s!\n", name);
        exit(1);
    }

    (*buffer) = calloc(1, info.st_size + 1);
    if (!(*buffer)) {
        printf("Template %s calloc failed!\n", name);
        exit(1);
    }

    if (info.st_size == 0) {
        (*buffer)[0] = '\0';
        return;
    }

    file = fopen(name, "rb");
    if (!file) {
        printf("Couldn't open template %s!\n", name);
        free(*buffer);
        exit(1);
    }
    if (fread(*buffer, info.st_size, 1, file) != 1) {
        printf("Couldn't read template %s!\n", name);
        free(*buffer);
        fclose(file);
        exit(1);
    }
    fclose(file);
}

/**
 * Processes a template.
 *
 * Variables in the form #VARIABLE# will be substituted for specified values.
 *
 * @param template
 * template to process.
 * @param vars
 * variables to replace. Array must be NULL-terminated.
 * @param values
 * variables to replace by. Must be the same size as vars, no NULL element allowed.
 * @return
 * filled-in template, that must be free()d be caller. NULL if memory allocation error.
 *
 * @note
 * returned string will be a memory block larger than required, for performance reasons.
 */
static char* do_template(const char* template, const char** vars, const char** values) {
    int count = 0;
    const char* sharp = template;
    int maxlen = 0;
    int var = 0;
    char* result;
    char* current_result;
    const char* end;

    while ((sharp = strchr(sharp, '#')) != NULL) {
        sharp++;
        count++;
    }
    if (!count)
        return strdup(template);
    if (count % 2) {
        printf("Malformed template, mismatched #!\n");
        return strdup(template);
    }

    while (vars[var] != NULL) {
        if (strlen(values[var]) > maxlen)
            maxlen = strlen(values[var]);
        var++;
    }
    result = calloc(1, strlen(template) + maxlen * (count / 2) + 1);
    if (!result)
        return NULL;
    current_result = result;

    sharp = template;
    while ((sharp = strchr(sharp, '#')) != NULL) {
        end = strchr(sharp + 1, '#');
        strncpy(current_result, template, sharp - template);
        if (end == sharp+1) {
            strcat(current_result, "#");
        }
        else {
        current_result = current_result + strlen(current_result);
        var = 0;
        while (vars[var] != 0 && strncmp(vars[var], sharp + 1, end - sharp - 1))
            var++;
        if (vars[var] == 0)
            printf("Wrong tag: %s\n", sharp);
        else
            strcpy(current_result, values[var]);
        }
        current_result = current_result + strlen(current_result);
        sharp = end + 1;
        template = sharp;
    }
    strcat(current_result, template);
    return result;
}

/**
 * Computes the shortest path from one file to another.
 *
 * @param from
 * origin.
 * @param to
 * destination.
 * @param result
 * string that will contain the calculated path. Must be large enough, no test done.
 * @warning
 * from and to must be absolute paths (starting with /).
 */
static void relative_path(const char* from, const char* to, char* result)
{
    const char* fslash;
    const char* rslash;

    result[0] = '\0';

    fslash = strchr(from + 1, '/');
    if (!fslash)
    {
        strcpy(result, to + 1);
        return;
    }

    rslash = strchr(to + 1, '/');
    while ( fslash && rslash && (fslash - from == rslash - to) && strncmp(from, to, fslash - from + 1) == 0)
    {
        from = fslash + 1;
        to = rslash + 1;
        fslash = strchr(fslash + 1, '/');
        rslash = strchr(rslash + 1, '/');
    }

    while (fslash)
    {
        strcat(result, "../");
        fslash = strchr(fslash + 1, '/');
    }
    if ( strlen( result ) && result[ strlen( result ) - 1 ] == '/' && *to == '/' )
        result[ strlen( result ) - 1 ] = '\0';
    strcat(result, to);
}

/**
 * Sorts the strings according to the last part of the filename (after the last /).
 *
 * @param left
 * first string.
 * @param right
 * second string.
 * @return
 * comparison on last element, and if equal then on whole string.
 */
static int sort_mapname( const void* left, const void* right )
{
    const char* l = *(const char**)left;
    const char* r = *(const char**)right;
    const char* sl = strrchr(l, '/');
    const char* sr = strrchr(r, '/');
    int c;

    if (!sl)
        sl = l;
    if (!sr)
        sr = r;
    c = strcasecmp(sl, sr);
    if (c)
        return c;

    return strcasecmp(l, r);
}

/**
 * Sorts the struct_map_info according to the last part of their path (after the last /).
 *
 * @param left
 * first item.
 * @param right
 * second item.
 * @return
 * comparison on last element, and if equal then on whole string.
 */
static int sort_map_info( const void* left, const void* right )
{
    struct_map_info* l = *(struct_map_info**)left;
    struct_map_info* r = *(struct_map_info**)right;
    const char* sl = strrchr(l->path, '/');
    const char* sr = strrchr(r->path, '/');
    int c;

    if (!sl)
        sl = l->path;
    if (!sr)
        sr = r->path;
    c = strcasecmp(sl, sr);
    if (c)
        return c;

    return strcasecmp(l->path, r->path);
}

/**
 * Sorts an array of maps_in_region by region name.
 *
 * @param left
 * first region.
 * @param right
 * second region.
 * @return
 * result of strcmp() for names.
 */
static int sort_region( const void* left, const void* right )
{
    return strcmp((*((maps_in_region**)left))->reg->name, (*((maps_in_region**)right))->reg->name);
}

/**
 * Adds a map to specified array, if it isn't already.
 *
 * @param info
 * map to add.
 * @param list
 * list to add to.
 *
 * @note
 * will allocate memory and update variables when required.
 */
void add_map(struct_map_info* info, struct_map_list* list)
{
    int map;
    for (map = 0; map < list->count; map++)
        if (list->maps[map] == info)
            return;

    if (list->count == list->allocated) {
        list->allocated += 50;
        list->maps = realloc(list->maps, list->allocated * sizeof(struct_map_info*));
    }
    list->maps[list->count] = info;
    list->count++;
}

/**
 * Gets or creates if required the info structure for a map.
 * @param path
 * map to consider.
 * @return
 * associated structure.
 */
struct_map_info* get_map_info(const char* path) {
    int map;
    struct_map_info* add;
    for (map = 0; map < maps_list.count; map++) {
        if (strcmp(maps_list.maps[map]->path, path) == 0)
            return maps_list.maps[map];
    }

    add = calloc(1, sizeof(struct_map_info));
    add->path = strdup(path);
    init_map_list(&add->exits_to);
    init_map_list(&add->exits_from);
    add_map(add, &maps_list);
    return add;
}

/**
 * Marks specified path as processed.
 *
 * @param path
 * map to remove.
 */
void list_map(const char* path) {
    int index;
    for (index = 0; index < found_maps_count; index++) {
        if (found_maps[index] && strcmp(path, found_maps[index]) == 0) {
            free(found_maps[index]);
            found_maps[index] = NULL;
            return;
        }
    }
    printf("Map processed but not found in directory reading? %s\n", path);
}

/**
 * Links a map to a region.
 *
 * Will not readd the map if already linked.
 *
 * @param map
 * map name.
 * @param region
 * region name.
 */
void add_map_to_region(struct_map_info* map, region* reg) {
    int test;
    int x, y;
    for (test = 0; test < region_count; test++) {
        if (regions[test]->reg == reg)
            break;
    }
    if (test == region_count) {
        if (test == region_allocated) {
            region_allocated++;
            regions = realloc(regions, sizeof(maps_in_region*) * region_allocated);
            regions[test] = calloc(1, sizeof(maps_in_region));
        }
        region_count++;
        regions[test]->reg = reg;
    }
    add_map(map, &regions[test]->maps_list);
    if (sscanf(map->path, "/world/world_%d_%d",&x,&y) == 2) {
        regions[test]->sum_x += (x-100);
        regions[test]->sum_y += (y-100);
        regions[test]->sum++;
        regions[test]->is_world = 1;
    }
}

/**
 * Saves a map to a file, based on jpg/png settings.
 *
 * @param file
 * opened file to which to save.
 * @param pic
 * picture to save.
 */
static void save_picture(FILE* file, gdImagePtr pic) {
    if (output_format == OF_PNG)
        gdImagePng(pic, file);
    else
        gdImageJpeg(pic, file, jpeg_quality);
}

/**
 * Creates a link between two maps if they are on different regions.
 * @param source
 * map from.
 * @param dest
 * map to.
 * @param linkname
 * name of the link as it should appear. Unused.
 */
static void add_region_link(mapstruct* source, mapstruct* dest, const char* linkname) {
    int search = 0;
    char entry[500];
    region* s, *d;

    s = get_region_by_map(source);
    d = get_region_by_map(dest);
    if (s == d)
        return;

    if (linkname && 0)
        snprintf(entry, sizeof(entry), "%s -> %s [ label = \"%s\" ]\n", s->name, d->name, linkname);
    else
        snprintf(entry, sizeof(entry), "%s -> %s\n", s->name, d->name);

    for (search = 0; search < regions_link_count; search++) {
        if (strcmp(regions_link[search], entry) == 0)
            return;
    }

    if (regions_link_count == regions_link_allocated) {
        regions_link_allocated += 10;
        regions_link = realloc(regions_link, sizeof(const char*) * regions_link_allocated);
    }
    regions_link[regions_link_count] = strdup(entry);
    regions_link_count++;
}

/**
 * Is the slaying field relevant for this item?
 *
 * @param item
 * item to check.
 * @return
 * 1 if relevant, 0 else.
 */
static int is_slaying(object* item) {
    return (item->type == LOCKED_DOOR || item->type == SPECIAL_KEY || item->type == CONTAINER || item->type == CHECK_INV);
}


/**
 * Returns a slaying_info_struct for specified slaying. Creates a new one if not yet found.
 *
 * @param slaying
 * value to get the structure of.
 * @return
 * structure for slaying. Never NULL.
 */
static slaying_info_struct* get_slaying_struct(const char* slaying) {
    slaying_info_struct* add;
    int l;
    for (l = 0; l < slaying_count; l++) {
        if (!strcmp(slaying_info[l]->slaying, slaying))
            return slaying_info[l];
    }
    add = (slaying_info_struct*)calloc(1, sizeof(slaying_info_struct));
    add->slaying = strdup(slaying);
    for (l = 0; l < S_MAX; l++)
        init_map_list(&add->maps[l]);

    if (slaying_count == slaying_allocated) {
        slaying_allocated += 10;
        slaying_info = (slaying_info_struct**)realloc(slaying_info, sizeof(slaying_info_struct*) * slaying_allocated);
    }

    slaying_info[slaying_count] = add;
    slaying_count++;

    return add;
}

/**
 * Adds the specified map to the slaying information if not already present.
 *
 * @param info
 * structure to add to.
 * @param item
 * one of the S_xxx values specifying what type of slaying this is.
 * @param map
 * map to add.
 */
static void add_map_to_slaying(slaying_info_struct* info, int item, struct_map_info* map) {
    add_map(map, &info->maps[item]);
}

/**
 * Adds the item's information to the map.
 *
 * @param source
 * map containing the item.
 * @param item
 * item which slaying field we're considering.
 */
static void add_slaying(struct_map_info* map, object* item) {
    slaying_info_struct* info;

    if (!item->slaying)
        /* can be undefined */
        return;

    info = get_slaying_struct(item->slaying);
    if (item->type == LOCKED_DOOR)
        add_map_to_slaying(info, S_DOOR, map);
    else if (item->type == SPECIAL_KEY)
        add_map_to_slaying(info, S_KEY, map);
    else if (item->type == CONTAINER)
        add_map_to_slaying(info, S_CONTAINER, map);
    else
        add_map_to_slaying(info, S_CONNECT, map);
}

/**
 * Recursively checks if the object should be considered for slaying information.
 *
 * @param map
 * map containing the items.
 * @param item
 * item to consider. Must not be NULL.
 */
static void check_slaying_inventory(struct_map_info* map, object* item) {
    object* inv;

    for (inv = item->inv; inv; inv = inv->below) {
        if (is_slaying(inv))
            add_slaying(map, inv);
        check_slaying_inventory(map, inv);
    }
}

/**
 * Processes a map.
 *
 * Generates the .html file, the pictures (big and small).
 *
 * @param name
 * file to process. Must start with a /, relative to Crossfire map directory.
 */
void domap(struct_map_info* info)
{
    mapstruct* m;
    int x, y;
    object* item;
    gdImagePtr pic;
    gdImagePtr small;
    FILE* out;
    struct stat stats;
    struct stat statspic;
    char mapname[500];
    char exit_path[500];
    char* tmp;
    char tmppath[MAX_BUF];

    char* exits_text;
    char* maplore;

    char htmlpath[500];         /* Map file path. */
    char mappic[500];           /* Name of map's full size picture. */
    char mapsmallpic[500];      /* Name of map's small size picture. */
    char mappicpath[500];       /* Path of map's full size picture. */
    char mapsmallpicpath[500];  /* Path of map's small size picture. */
    char indexpath[500];        /* Relative path of full index. */
    char regionpath[500];       /* Path to region's filename. */
    char regionname[500];       /* Name of map's region. */
    char regionindexpath[500];  /* Path to region index file. */
    char worldmappath[500];     /* Path to world map. */
    int needpic = 0;
    struct_map_info* link;

    const char* vars[] = { "NAME", "MAPPATH", "MAPNAME", "MAPPIC", "MAPSMALLPIC", "MAPEXIT", "INDEXPATH", "REGIONPATH", "REGIONNAME", "REGIONINDEXPATH", "WORLDMAPPATH", "MAPLORE", NULL, NULL, NULL };
    const char* values[] = { info->path, htmlpath, NULL, mappic, mapsmallpic, "", indexpath, regionpath, regionname, regionindexpath, worldmappath, NULL, NULL, NULL, NULL };
    int vars_count = 0;
    while (vars[vars_count])
        vars_count++;

    if (list_unused_maps)
        list_map(info->path);

    if (show_maps)
        printf(" processing map %s\n", info->path);

    m = ready_map_name(info->path ,0);
    if (!m) {
        printf("couldn't load map %s\n", info->path);
        return;
    }

    do_exit_map(m);

    if (!rawmaps)
        do_auto_apply(m);

    if (m->maplore)
        info->lore = strdup(m->maplore);
    tmp = strrchr(m->path, '/');
    if (tmp)
        info->filename = strdup(tmp + 1);
    else
        info->filename = strdup(m->path);

    if (m->name)
        info->name = strdup(m->name);
    else
        info->name = strdup(info->filename);
    values[2] = info->name;

    add_map_to_region(info, get_region_by_map(m));

    relative_path(info->path, "/maps.html", indexpath);
    relative_path(info->path, "/world.html", worldmappath);
    relative_path(info->path, "/regions.html", regionindexpath);

    strcpy(regionname, get_name_of_region_for_map(m));
    strcpy(exit_path, "/");
    strcat(exit_path, regionname);
    strcat(exit_path, ".html");
    relative_path(info->path, exit_path, regionpath);

    tmp = strrchr(info->path, '/');
    strcpy(mapname, tmp + 1);
    strcpy(mappic, mapname);
    strcat(mappic, output_extensions[output_format]);
    strcpy(mapsmallpic, mapname);
    strcat(mapsmallpic, ".small");
    strcat(mapsmallpic, output_extensions[output_format]);

    strcpy(htmlpath, root);
    strncat(htmlpath, info->path, 500 - strlen(htmlpath));

    strcpy(mappicpath, htmlpath);
    strcat(mappicpath, output_extensions[output_format]);
    strcpy(mapsmallpicpath, htmlpath);
    strcat(mapsmallpicpath, ".small");
    strcat(mapsmallpicpath, output_extensions[output_format]);

    strcat(htmlpath, ".html");
    make_path_to_file(htmlpath);

    if (force_pics)
        needpic = 1;
    else if (generate_pics) {
        create_pathname(info->path, tmppath, MAX_BUF);
        stat(tmppath, &stats);
        if (stat(mappicpath, &statspic) || (statspic.st_mtime < stats.st_mtime))
            needpic = 1;
        else if (stat(mapsmallpicpath, &statspic) || (statspic.st_mtime < stats.st_mtime))
            needpic = 1;
    }
    else
        needpic = 0;

    if (needpic) {
        pic = gdImageCreateTrueColor( MAP_WIDTH(m) * 32, MAP_HEIGHT(m) * 32 );
        created_pics++;
    }
    else
        cached_pics++;

    for ( x = 0; x < 4; x++ )
        if ( m->tile_path[x] != NULL ) {
            path_combine_and_normalize(m->path, m->tile_path[x], exit_path, sizeof(exit_path));
            create_pathname(exit_path, tmppath, MAX_BUF);
            if (stat(tmppath, &stats)) {
                printf("  map %s doesn't exist in map %s, for tile %d.\n", exit_path, info->path, x);
            }
            else
            {
                link = get_map_info(exit_path);
                add_map(link, &info->exits_from);
                add_map(info, &link->exits_to);

                if (do_regions_link) {
                    mapstruct* link = ready_map_name(exit_path, 0);
                    if (link && link != m) {
                        /* no need to link a map with itself. Also, if the exit points to the same map, we don't
                        * want to reset it. */
                        add_region_link(m, link, NULL);
                        link->reset_time = 1;
                        link->in_memory = MAP_IN_MEMORY;
                        delete_map(link);
                    }
                }
            }
        }

    for ( x = MAP_WIDTH(m) - 1; x >= 0; x-- )
        for ( y = MAP_HEIGHT(m) - 1; y >= 0 ; y-- ) {
            for ( item = GET_MAP_OB(m, x, y); item; item = item->above ) {
                if (item->type == EXIT || item->type == TELEPORTER || item->type == PLAYER_CHANGER) {
                    char ep[500];
                    const char* start;

                    if (!item->slaying) {
                        ep[0] = '\0';
                        if (warn_no_path)
                            printf(" exit without any path at %d, %d on %s\n", item->x, item->y, info->path);
                    } else {

                        memset(ep, 0, 500);
                        if (strcmp(item->slaying, "/!"))
                            strcpy(ep, EXIT_PATH(item));
                        else
                        {
                            if (!item->msg)
                            {
                                printf("  random map without message in %s at %d, %d\n", info->path, item->x, item->y);
                            } else {
                                /* Some maps have a 'exit_on_final_map' flag, ignore it. */
                                start = strstr(item->msg, "\nfinal_map ");
                                if (!start && strncmp(item->msg, "final_map", strlen("final_map")) == 0)
                                    /* Message start is final_map, nice */
                                    start = item->msg;
                                if (start)
                                {
                                    char* end = strchr(start + 1, '\n');
                                    start += strlen("final_map") + 2;
                                    strncpy(ep, start, end - start);
                                }
                            }
                        }

                        if (strlen(ep)) {
                            path_combine_and_normalize(m->path, ep, exit_path, 500);
                            create_pathname(exit_path, tmppath, MAX_BUF);
                            if (stat(tmppath, &stats)) {
                                printf("  map %s doesn't exist in map %s, at %d, %d.\n", ep, info->path, item->x, item->y);
                            }
                            else
                            {
                                link = get_map_info(exit_path);
                                add_map(link, &info->exits_from);
                                add_map(info, &link->exits_to);

                                if (do_regions_link) {
                                    mapstruct* link = ready_map_name(exit_path, 0);
                                    if (link && link != m) {
                                        /* no need to link a map with itself. Also, if the exit points to the same map, we don't
                                         * want to reset it. */
                                        add_region_link(m, link, item->arch->clone.name);
                                        link->reset_time = 1;
                                        link->in_memory = MAP_IN_MEMORY;
                                        delete_map(link);
                                    }
                                }
                            }
                        }
                    }
                } else if (is_slaying(item))
                    add_slaying(info, item);

                check_slaying_inventory(info, item);

                if (item->invisible)
                    continue;

                if (needpic) {
                    if (gdfaces[item->face->number] == NULL)
                    {
                        gdfaces[item->face->number] = gdImageCreateFromPngPtr(facesets[0].faces[item->face->number].datalen, facesets[0].faces[item->face->number].data);
                        pics_allocated++;
                    }
                    if (gdfaces[item->face->number] != 0 && !(item->head && item->face->number == item->head->face->number))
                    {
                        gdImageCopy(pic, gdfaces[item->face->number], x * 32, y * 32, 0, 0, gdfaces[item->face->number]->sx, gdfaces[item->face->number]->sy);
                    }
                }
            }
        }

    if (info->lore) {
        values[11] = info->lore;
        maplore = do_template(map_lore_template, vars, values);
    }
    else {
        maplore = do_template(map_no_lore_template, vars, values);
    }
    values[11] = maplore;

    if (info->exits_from.count)
    {
        char* one_exit = NULL;
        int exit;
        char relative[500];
        char exitname[500];

        vars[vars_count] = "EXITNAME";
        vars[vars_count+1] = "EXITFILE";

        qsort(info->exits_from.maps, info->exits_from.count, sizeof(const char*), sort_map_info);
        for (exit = 0; exit < info->exits_from.count; exit++)
        {
            relative_path(info->path, info->exits_from.maps[exit]->path, relative);
            tmp = strrchr(relative, '/');
            if (!tmp)
                strcpy(exitname, relative);
            else
                strcpy(exitname, tmp+1);
            strcat(relative, ".html");
            values[vars_count] = exitname;
            values[vars_count+1] = relative;
            one_exit = cat_template(one_exit, do_template(map_exit_template, vars, values));
        }
        vars[vars_count] = "EXIT";
        vars[vars_count+1] = NULL;
        values[vars_count] = one_exit;
        exits_text = do_template(map_with_exit_template, vars, values);
        free(one_exit);
    }
    else
        exits_text = do_template(map_no_exit_template, vars, values);

    values[5] = exits_text;
    vars[vars_count] = NULL;
    out = fopen(htmlpath, "w+");
    tmp = do_template(map_template, vars, values);
    fprintf(out, tmp);
    fclose(out);
    free(tmp);
    free(exits_text);
    free(maplore);

    if (needpic) {
        out = fopen(mappicpath, "wb+");
        save_picture(out, pic);
        fclose(out);

        small = gdImageCreateTrueColor( MAP_WIDTH(m) * size_small, MAP_HEIGHT(m) * size_small );
        gdImageCopyResampled(small, pic, 0, 0, 0, 0, MAP_WIDTH(m) * size_small, MAP_HEIGHT(m) * size_small, MAP_WIDTH(m) * 32, MAP_HEIGHT(m) * 32 );
        out = fopen(mapsmallpicpath, "wb+");
        save_picture(out, small);
        fclose(out);
        gdImageDestroy(small);

        gdImageDestroy(pic);
    }

    m->reset_time = 1;
    m->in_memory = MAP_IN_MEMORY;
    delete_map(m);
}

/**
 * Creates the page for a map index.
 *
 * @param dest
 * 
 * @param maps_list
 * maps in the index.
 * @param template
 * global page template.
 * @param template_letter
 * template for one letter of the index.
 * @param template_map
 * template for one map.
 * @param vars
 * template variables to give access to.
 * @param values
 * associated values.
 * @return
 * processed template. Should be free() by the caller.
 */
char* do_map_index(const char* dest, struct_map_list* maps_list, const char* template, const char* template_letter, const char* template_map, const char** vars, const char** values) {
#define VARSADD 6
    int map;
    char* string;
    char name[500];
    char mappath[500];
    char maphtml[500];
    char count[50];
    char lettercount[50];
    char* tmp;
    const char** idx_vars;
    const char** idx_values;
    char str_letter[2];
    char last_letter;
    char index_path[500];
    char* mapstext = NULL;
    int byletter;
    int basevalues;

    if (!generate_index)
        return strdup("");

    if (vars)
        for (basevalues = 0; vars[basevalues] != NULL; basevalues++) ;
    else
        basevalues = 0;

    idx_vars = malloc(sizeof(char*) * (basevalues+VARSADD));
    idx_vars[0] = "MAPCOUNT";
    memcpy(&idx_vars[1], vars, sizeof(char*) * basevalues);
    idx_vars[basevalues+VARSADD-1] = NULL;

    idx_values = malloc(sizeof(char*) * (basevalues+VARSADD-1));
    memcpy(&idx_values[1], values, sizeof(char*) * basevalues);

    string = NULL;

    sprintf(count, "%d", maps_list->count);
    idx_values[0] = count;

    idx_vars[basevalues+1] = "MAPNAME";
    idx_vars[basevalues+2] = "MAPPATH";
    idx_vars[basevalues+3] = "MAPHTML";
    idx_vars[basevalues+4] = NULL;

    qsort(maps_list->maps, maps_list->count, sizeof(const char*), sort_map_info);

    last_letter = '\0';
    str_letter[0] = '\0';
    str_letter[1] = '\0';

    strcpy(index_path, "/");
    strcat(index_path, dest);

    string = NULL;
    for (map = 0; map < maps_list->count; map++ ) {
        tmp = strrchr(maps_list->maps[map]->path, '/');
        if (tmp)
            strcpy(name, tmp + 1);
        else {
            printf(" warning: map with no / in path: %s\n", maps_list->maps[map]->path);
            strcpy(name, maps_list->maps[map]->path);
        }
        if (tolower(name[0]) != last_letter) {
            if (mapstext != NULL) {
                idx_vars[basevalues+1] = "MAPS";
                idx_vars[basevalues+2] = "LETTER";
                idx_vars[basevalues+3] = "LETTERCOUNT";
                idx_vars[basevalues+4] = NULL;
                idx_values[basevalues+1] = mapstext;
                idx_values[basevalues+2] = str_letter;
                sprintf(lettercount, "%d", byletter);
                idx_values[basevalues+3] = lettercount;
                string = cat_template(string, do_template(template_letter, idx_vars, idx_values));
                free(mapstext);
                mapstext = NULL;
                idx_values[basevalues+2] = NULL;
            }
            last_letter = tolower(name[0]);
            str_letter[0] = last_letter;
            byletter = 0;
        }
        idx_vars[basevalues+1] = "MAPNAME";
        idx_vars[basevalues+2] = "MAPPATH";
        idx_vars[basevalues+3] = "MAPHTML";
        idx_values[basevalues+1] = maps_list->maps[map]->name ? maps_list->maps[map]->name : maps_list->maps[map]->path;
        relative_path(index_path, maps_list->maps[map]->path, mappath);
        strcpy(maphtml, mappath);
        strcat(maphtml, ".html");
        idx_values[basevalues+2] = mappath;
        idx_values[basevalues+3] = maphtml;
        mapstext = cat_template(mapstext, do_template(template_map, idx_vars, idx_values));
        byletter++;
    }
    if (last_letter != '\0') {
        idx_vars[basevalues+1] = "MAPS";
        idx_vars[basevalues+2] = "LETTER";
        idx_vars[basevalues+3] = "LETTERCOUNT";
        idx_vars[basevalues+4] = NULL;
        idx_values[basevalues+1] = mapstext;
        idx_values[basevalues+2] = str_letter;
        sprintf(lettercount, "%d", byletter);
        idx_values[basevalues+3] = lettercount;
        string = cat_template(string, do_template(template_letter, idx_vars, idx_values));
        free(mapstext);
        mapstext = NULL;
        idx_values[basevalues+2] = NULL;
    }

    idx_values[basevalues+1] = string;
    idx_vars[basevalues+1] = "LETTERS";
    idx_vars[basevalues+2] = NULL;
    tmp = do_template(template, idx_vars, idx_values);
    free(string);
    free(idx_vars);
    free(idx_values);
    return tmp;
}

/**
 * Generates the web page for a region.
 *
 * @param reg
 * region/maps for which to generate.
 *
 * @note
 * will sort the maps.
 */
void do_region(maps_in_region* reg) {
    char* string;
    FILE* index;
    char html[500];

    const char* vars[] = { "REGIONNAME", "REGIONHTML", "REGIONLONGNAME", "REGIONDESC", NULL };
    const char* values[] = { reg->reg->name, html, NULL, NULL };

    printf("Generating map index for region %s...", reg->reg->name);

    values[2] = get_region_longname(reg->reg);
    values[3] = get_region_msg(reg->reg);

    strcpy(html, reg->reg->name);
    strcat(html, ".html");

    string = do_map_index(html, &reg->maps_list, region_template, region_letter_template, region_map_template, vars, values);

    strcpy(html, root);
    strcat(html, "/");
    strcat(html, reg->reg->name);
    strcat(html, ".html");
    index = fopen(html, "w+");
    fprintf(index, string);
    fclose(index);
    free(string);

    printf(" done.\n");

}

/**
 * Generates all map indexes for a region.
 */
void do_maps_index_by_region() {
    int reg;

    qsort(regions, region_count, sizeof(maps_in_region*), sort_region);

    for (reg = 0; reg < region_count; reg++ )
        do_region(regions[reg]);
}

/**
 * Generates global map index, file maps.html.
 */
void do_maps_index() {
    char index_path[500];
    char* tmp;
    FILE* index;

    printf("Generating global map index in maps.html...");

    tmp = do_map_index("maps.html", &maps_list, index_template, index_letter, index_map, NULL, NULL);

    strcpy(index_path, root);
    strcat(index_path, "/maps.html");
    index = fopen(index_path, "w+");
    fprintf(index, tmp);
    fclose(index);
    free(tmp);

    printf(" done.\n");
}

/**
 * Generates region index.
 */
void do_region_index() {
    char* txt;
    char* final;
    char count[10];
    maps_in_region* region;
    int reg;
    char file[500];
    const char* vars[] = {"REGIONCOUNT", "REGIONFILE", "REGIONNAME", NULL};
    const char* values[] = {count, file, NULL};
    FILE* out;

    printf("Generating regions index in regions.html...");

    sprintf(count, "%d", region_count);
    txt = NULL;

    for (reg = 0; reg < region_count; reg++) {
        region = regions[reg];
        sprintf(file, "%s.html", region->reg->name);
        values[2] = get_region_longname(region->reg);
        txt = cat_template(txt, do_template(index_region_region_template, vars, values));
    }
    vars[1] = "REGIONS";
    values[1] = txt;
    vars[2] = NULL;
    final = do_template(index_region_template, vars, values);
    free(txt);

    strcpy(file, root);
    strcat(file, "/regions.html");
    out = fopen(file, "w+");
    fprintf(out, final);
    fclose(out);
    free(final);

    printf(" done.\n");

}

/**
 * Generates a big world map.
 */
void do_world_map() {
#define SIZE 50
    int x, y;
    FILE* out;
    int wx, wy;
    char file[500];
    char* map = NULL;
    char* total;
    char* row = NULL;
    char mapleft[10], maptop[10], mapright[10], mapbottom[10];
    const char* vars[] = { NULL, NULL, "MAPLEFT", "MAPTOP", "MAPRIGHT", "MAPBOTTOM", NULL };
    const char* values[] = { NULL, NULL, mapleft, maptop, mapright, mapbottom, NULL };
    char name[100];
    char mappath[500], mapraw[500], mapregion[500];
    gdImagePtr pic;
    gdImagePtr small;
    gdFontPtr font;
    int region, color;

    if (!world_map)
        return;

    printf("Generating world map in world.html...");
    fflush(stdout);

    pic = gdImageCreateTrueColor(SIZE*30, SIZE*30);

    strcpy(file, root);
    strcat(file, "/world.html");

    wx = 100;
    wy = 100;

    for (y = 0; y < 30; y++) {
        for (x = 0; x < 30; x++) {
            values[0] = name;
            vars[0] = "MAPNAME";
            vars[1] = "MAPPATH";
            values[1] = mappath,
            sprintf(name, "world_%d_%d", wx, wy);
            sprintf(mappath, "world/%s.html", name);
            sprintf(mapleft, "%d", SIZE*x);
            sprintf(maptop, "%d", SIZE*y);
            sprintf(mapright, "%d", SIZE*(x+1)-1);
            sprintf(mapbottom, "%d", SIZE*(y+1)-1);

            map = cat_template(map, do_template(world_map_template, vars, values));

            sprintf(mappath, "%s/world/%s%s", root, name, output_extensions[output_format]);

            out = fopen(mappath, "rb");
            if (output_format == OF_PNG)
                small = gdImageCreateFromPng(out);
            else
                small = gdImageCreateFromJpeg(out);
            fclose(out);
            if (!small) {
                printf("\n  warning: pic not found for world_%d_%d", wx, wy);
                continue;
            }
            gdImageCopyResized(pic, small, SIZE*x, SIZE*y, 0, 0, SIZE, SIZE, small->sx, small->sy);
            gdImageDestroy(small);

            wx++;
        }
        wy++;
        wx = 100;
        values[0] = map;
        vars[0] = "MAPS";
        vars[1] = NULL;
        row = cat_template(row, do_template(world_row_template, vars, values));
        free(map);
        map = NULL;
    }
    sprintf(mappath, "world%s", output_extensions[output_format]);
    sprintf(mapraw, "world_raw%s", output_extensions[output_format]);
    sprintf(mapregion, "world_regions%s", output_extensions[output_format]);

    values[0] = row;
    vars[0] = "MAPS";
    values[1] = mappath;
    vars[1] = "WORLDMAP";
    values[2] = mapraw;
    vars[2] = "WORLDRAW";
    values[3] = mapregion;
    vars[3] = "WORLDREGIONS";
    vars[4] = NULL;
    total = do_template(world_template, vars, values);
    free(row);
    out = fopen(file, "w+");
    fprintf(out, total);
    free(total);
    fclose(out);

    sprintf(mappath, "%s/world_raw%s", root, output_extensions[output_format]);
    out = fopen(mappath, "wb+");
    save_picture(out, pic);
    fclose(out);

    /* Write region names. */
    small = gdImageCreateTrueColor(SIZE*30, SIZE*30);
    font = gdFontGetGiant();
    color = gdImageColorAllocateAlpha(pic, 255, 0, 0, 20);
    for (region = 0; region < region_allocated; region++) {
        if (!regions[region]->is_world || regions[region]->sum == 0)
            continue;

        x = regions[region]->sum_x * SIZE / regions[region]->sum + SIZE / 2 - strlen(regions[region]->reg->name) * font->w / 2;
        y = regions[region]->sum_y * SIZE / regions[region]->sum + SIZE / 2 - font->h / 2;
        gdImageString(small, font, x, y, regions[region]->reg->name, color);
        gdImageString(pic, font, x, y, regions[region]->reg->name, color);

        /* For exit/road map, size isn't the same. */
        x = regions[region]->sum_x * 50 / regions[region]->sum + 50 / 2 - strlen(regions[region]->reg->name) * font->w / 2;
        y = regions[region]->sum_y * 50 / regions[region]->sum + 50 / 2 - font->h / 2;
        gdImageString(infomap, font, x, y, regions[region]->reg->name, color);
    }

    sprintf(mappath, "%s/world_regions%s", root, output_extensions[output_format]);
    out = fopen(mappath, "wb+");
    save_picture(out, small);
    fclose(out);
    gdImageDestroy(small);

    sprintf(mappath, "%s/world%s", root, output_extensions[output_format]);
    out = fopen(mappath, "wb+");
    save_picture(out, pic);
    fclose(out);
    gdImageDestroy(pic);

    printf(" done.\n");
#undef SIZE
}

const char* ignore_path[] = {
    "/Info",
    "/editor",
    "/python",
    "/styles",
    "/templates",
    "/test",
    "/unlinked",
    NULL };

const char* ignore_name[] = {
    ".",
    "..",
    ".svn",
    "README",
    NULL };

void find_maps(const char* from) {
    struct dirent* file;
    struct stat statbuf;
    int status, ignore;
    char path[1024], full[1024];
    DIR* dir;

    for (ignore = 0; ignore_path[ignore] != NULL; ignore++) {
        if (strcmp(from, ignore_path[ignore]) == 0)
            return;
    }

    snprintf(path, sizeof(path), "%s/%s%s", settings.datadir, settings.mapdir, from);
    dir = opendir(path);

    if (dir) {
        for (file = readdir(dir); file; file = readdir(dir)) {

            for (ignore = 0; ignore_name[ignore] != NULL; ignore++) {
                if (strcmp(file->d_name, ignore_name[ignore]) == 0)
                    break;
            }
            if (ignore_name[ignore] != NULL)
                continue;

            snprintf(full, sizeof(full), "%s/%s", path, file->d_name);

            status = stat(full, &statbuf);
            if ((status!=-1) && (S_ISDIR(statbuf.st_mode))) {
                snprintf(full, sizeof(full), "%s/%s", from, file->d_name);
                find_maps(full);
                continue;
            }
            if (found_maps_count == found_maps_allocated) {
                found_maps_allocated += 50;
                found_maps = realloc(found_maps, found_maps_allocated * sizeof(char*));
            }
            snprintf(full, sizeof(full), "%s/%s", from, file->d_name);
            found_maps[found_maps_count++] = strdup(full);
        }
        closedir(dir);
    }
}

void dump_unused_maps() {
    FILE* dump;
    char path[1024];
    int index, found = 0;

    snprintf(path, sizeof(path), "%s/%s", root, "maps.unused");
    dump = fopen(path, "w+");
    if (dump == NULL) {
        printf("Unable to open file maps.unused!\n");
        return;
    }
    for (index = 0; index < found_maps_count; index++) {
        if (found_maps[index] != NULL) {
            fprintf(dump, "%s\n", found_maps[index]);
            free(found_maps[index]);
            found++;
        }
    }
    fclose(dump);
    printf("%d unused maps.\n", found);
}

void write_world_info() {
    FILE* file;
    char path[MAX_BUF];

    printf("Saving exit/blocking/road information...");
    snprintf(path, sizeof(path), "%s/%s%s", root, "world_info", output_extensions[output_format]);
    file = fopen(path, "wb+");
    save_picture(file, infomap);
    fclose(file);
    printf("done.\n");
    gdImageDestroy(infomap);
    infomap = NULL;
}

void write_regions_link() {
    FILE* file;
    char path[MAX_BUF];
    int link;

    if (!do_regions_link)
        return;

    printf("Writing regions link file...");
    snprintf(path, sizeof(path), "%s/%s", root, "region_links.dot");
    file = fopen(path, "wb+");
    fprintf(file, "digraph {\n");
    for (link = 0; link < regions_link_count; link++)
        fprintf(file, regions_link[link]);
    fprintf(file, "}\n");
    fclose(file);
    printf("done.\n");
}

/**
 * Helper function to write a map to a file with its link and full path.
 *
 * @param file
 * where to write.
 * @param map
 * map info to write.
 */
static void write_slaying_map_name(FILE* file, struct_map_info* map) {
    const char* last = strrchr(map->path, '/');
    const char* first;
    if (last) {
        last++;
        first = strchr(map->path, '/') + 1;
    } else {
        last = map->path;
        first = map->path;
    }
    fprintf(file, "<a href=\"%s.html\">%s</a> (full map path: %s)", first, last, map->path);
}

/**
 * Writes all maps of the specified slaying information.
 *
 * @param file
 * file to write to.
 * @param info
 * slaying information to write.
 * @param item
 * which of the S_xxx to write.
 * @param with
 * text to write when there are maps to write. Mustn't be NULL.
 * @param without
 * text to write when there are no maps. Can be NULL.
 */
static void write_one_slaying_info(FILE* file, slaying_info_struct* info, int item, const char* with, const char* without) {
    int map;
    if (info->maps[item].count == 0) {
        if (without)
            fprintf(file, without);
        return;
    }

    qsort(info->maps[item].maps, info->maps[item].count, sizeof(const char*), sort_mapname);

    fprintf(file, with);
    fprintf(file, "<ul>\n");
    for (map = 0; map < info->maps[item].count; map++) {
        fprintf(file, "\t<li>");
        write_slaying_map_name(file, info->maps[item].maps[map]);
        fprintf(file, "</li>\n");
    }
    fprintf(file, "</ul>\n");
}

/**
 * Helper function to sort an array of slaying_info_struct.
 *
 * @param left
 * first item.
 * @param right
 * second item.
 * @return
 * sort order.
 */
static int sort_slaying( const void* left, const void* right )
{
    slaying_info_struct* l = *(slaying_info_struct**)left;
    slaying_info_struct* r = *(slaying_info_struct**)right;
    return strcasecmp(l->slaying, r->slaying);
}

/**
 * Writes all slaying info to file.
 */
void write_slaying_info() {
    FILE* file;
    char path[MAX_BUF];
    int lock;
    slaying_info_struct* info;

    printf("Writing slaying info file...");

    qsort(slaying_info, slaying_count, sizeof(slaying_info_struct*), sort_slaying);

    snprintf(path, sizeof(path), "%s/%s", root, "slaying_info.html");
    file = fopen(path, "wb+");

    fprintf(file, "<html>\n<head>\n<title>Slaying information</title>\n</head>\n<body>\n");
    fprintf(file, "<p>This is a list of various slaying fields on keys, containers, doors, detectors.</p>");

    for (lock = 0; lock < slaying_count; lock++) {
        info = slaying_info[lock];
        fprintf(file, "<h1>%s</h1>\n", info->slaying);

        if (info->maps[S_DOOR].count == 0 && info->maps[S_CONTAINER].count == 0 && info->maps[S_CONNECT].count == 0) {
            fprintf(file, "No door, container or detector matching this slaying.<br />\n");
        } else {
            write_one_slaying_info(file, info, S_DOOR, "Connected doors:\n", NULL);
            write_one_slaying_info(file, info, S_CONTAINER, "Matching containers:\n", NULL);
            write_one_slaying_info(file, info, S_CONNECT, "Detectors and such:\n", NULL);
        }
        write_one_slaying_info(file, info, S_KEY, "Matching keys:\n", "No key with this slaying.<br />\n");
    }

    fprintf(file, "</body>\n</html>\n");

    fclose(file);
    printf("done.\n");
}

/**
 * Prints usage information, and exit.
 *
 * @param program
 * program path.
 */
void do_help(const char* program) {
    printf("Crossfire Mapper will generate pictures of maps, and create indexes for all maps and regions.\n\n");
    printf("Syntax: %s\n\n", program);
    printf("Optional arguments:\n");
    printf("  -nopics             don't generate pictures.\n");
    printf("  -noindex            don't generate global map index.\n");
    printf("  -root=<path>        destination path. Default 'html'.\n");
    printf("  -limit=<number>     stop processing after this number of maps, -1 to do all maps (default).\n");
    printf("  -showmaps           outputs the name of maps as they are processed.\n");
    printf("  -jpg[=quality]      generate jpg pictures, instead of default png. Quality should be 0-95, -1 for automatic.\n");
    printf("  -forcepics          force to regenerate pics, even if pics's date is after map's.\n");
    printf("  -addmap=<map>       adds a map to process. Path is relative to map's directory root.\n");
    printf("  -rawmaps            generates maps pics without items on random (shop, treasure) tiles.\n");
    printf("  -warnnopath         inform when an exit has no path set.\n");
    printf("  -listunusedmaps     finds all unused maps in the maps directory.\n");
    printf("  -noworldmap         don't write the world map in world.png.\n");
    printf("  -noregionslink      don't generate regions relation file.\n");
    printf("  -regionslink        generate regions relation file.\n");
    printf("\n\n");
    exit(0);
}

/**
 * Handles command-line parameters.
 *
 * @param argc
 * number of parameters, including program name.
 * @param argv
 * arguments, including program name.
 */
void do_parameters(int argc, char** argv) {
    int arg = 1;
    char path[500];

    root[0] = '\0';

    while (arg < argc) {
        if (strcmp(argv[arg], "-nopics") == 0)
            generate_pics = 0;
        else if (strcmp(argv[arg], "-noindex") == 0)
            generate_index = 0;
        else if (strncmp(argv[arg], "-root=", 6) == 0)
            strncpy(root, argv[arg] + 6, 500);
        else if (strncmp(argv[arg], "-limit=", 7) == 0)
            map_limit = atoi(argv[arg] + 7);
        else if (strcmp(argv[arg], "-showmaps") == 0)
            show_maps = 1;
        else if (strcmp(argv[arg], "-jpg") == 0) {
            output_format = OF_JPG;
            if (argv[arg][4] == '=') {
                jpeg_quality = atoi(argv[arg] + 5);
                if (jpeg_quality < 0)
                    jpeg_quality = -1;
            }
        }
        else if (strcmp(argv[arg], "-forcepics") == 0)
            force_pics = 1;
        else if (strncmp(argv[arg], "-addmap=", 8) == 0) {
            if (*(argv[arg] + 8) == '/')
                strncpy(path, argv[arg] + 8, 500);
            else
                snprintf(path, 500, "/%s", argv[arg] + 8);
            add_map(get_map_info(path), &maps_list);
        }
        else if (strcmp(argv[arg], "-rawmaps") == 0)
            rawmaps = 1;
        else if (strcmp(argv[arg], "-warnnopath") == 0)
            warn_no_path = 1;
        else if (strcmp(argv[arg], "-listunusedmaps") == 0)
            list_unused_maps = 1;
        else if (strcmp(argv[arg], "-noworldmap") == 0)
            world_map = 0;
        else if (strcmp(argv[arg], "-noregionslink") == 0)
            do_regions_link = 0;
        else if (strcmp(argv[arg], "-regionslink") == 0)
            do_regions_link = 1;
        else
            do_help(argv[0]);
        arg++;
    }
    if (!strlen(root))
        strcpy(root, "html");
    if (root[strlen(root) - 1] == '/')
        root[strlen(root) - 1] = '\0';
    if (map_limit < -1)
        map_limit = -1;
}

/**
 * Ensures destination directory exists.
 */
void create_destination() {
    char dummy[502];
    strcpy(dummy, root);
    strcat(dummy, "/a");
    make_path_to_file(dummy);
}

/**
 * Helper to write yes/no.
 *
 * @param value
 * value to print.
 * @return
 * "no" if value == 0, "yes" else.
 */
static const char* yesno(int value) {
    return (value ? "yes" : "no");
}

int main(int argc, char** argv)
{
    int current_map = 0;
    char max[50];

    init_map_list(&maps_list);
    pics_allocated = 0;

    do_parameters(argc, argv);

    printf("Initializing Crossfire data...\n");

    settings.debug = 0;

    init_globals();
    init_library();
    init_archetypes();
    init_artifacts();
    init_formulae();
    init_readable();
    init_regions();

    init_gods();
    read_client_images();

    printf("\n\n done.\n\n");

    create_destination();
    gdfaces = calloc(1, sizeof(gdImagePtr) * nrofpixmaps);

    read_template("templates/map.template", &map_template);
    read_template("templates/map_no_exit.template", &map_no_exit_template);
    read_template("templates/map_with_exit.template", &map_with_exit_template);
    read_template("templates/map_exit.template", &map_exit_template);
    read_template("templates/map_lore.template", &map_lore_template);
    read_template("templates/map_no_lore.template", &map_no_lore_template);

    read_template("templates/index.template", &index_template);
    read_template("templates/index_letter.template", &index_letter);
    read_template("templates/index_map.template", &index_map);

    read_template("templates/region.template", &region_template);
    read_template("templates/region_letter.template", &region_letter_template);
    read_template("templates/region_map.template", &region_map_template);

    read_template("templates/index_region.template", &index_region_template);
    read_template("templates/index_region_region.template", &index_region_region_template);

    read_template("templates/world.template", &world_template);
    read_template("templates/world_row.template", &world_row_template);
    read_template("templates/world_map.template", &world_map_template);

    if (map_limit != -1)
        sprintf(max, "%d", map_limit);
    else
        strcpy(max, "(none)");
    printf("Crossfire map browser generator\n");
    printf("-------------------------------\n\n");
    printf("Parameters:\n");
    printf("  path to write files:                 %s\n", root);
    printf("  maximum number of maps to process:   %s\n", max);
    printf("  will generate map picture:           %s\n", yesno(generate_pics));
    printf("  will always generate map picture:    %s\n", yesno(force_pics));
    printf("  picture output format:               %s\n", output_extensions[output_format]);
    if (output_format == OF_JPG)
        printf("  JPEG quality:                        %d\n", jpeg_quality);
    printf("  will generate map index:             %s\n", yesno(generate_index));
    printf("  show map being processed:            %s\n", yesno(show_maps));
    printf("  generate raw maps:                   %s\n", yesno(rawmaps));
    printf("  warn of exit without path:           %s\n", yesno(warn_no_path));
    printf("  list unused maps:                    %s\n", yesno(list_unused_maps));
    printf("  generate world map:                  %s\n", yesno(world_map));
    printf("  generate regions link file:          %s\n", yesno(do_regions_link));
    printf("\n");

    if (list_unused_maps) {
        printf("listing all maps...");
        find_maps("");
        printf("done, %d maps found.\n", found_maps_count);
        qsort(found_maps, found_maps_count, sizeof(char*), sortbyname);
    }

    /* exit/blocking information. */
    infomap = gdImageCreateTrueColor(30 * 50, 30 * 50);
    color_unlinked_exit = gdImageColorResolve(infomap, 255, 0, 0);
    color_linked_exit = gdImageColorResolve(infomap, 255, 255, 255);
    color_road = gdImageColorResolve(infomap, 0, 255, 0);
    color_blocking = gdImageColorResolve(infomap, 0, 0, 255);
    color_slowing = gdImageColorResolve(infomap, 0, 0, 127);

    printf("browsing maps...\n");

    get_map_info(first_map_path);

    while (current_map < maps_list.count)
    {
        domap(maps_list.maps[current_map++]);
        if (current_map % 100 == 0)
        {
            printf(" %d maps processed, %d map pictures created, %d map pictures were uptodate. %d faces used.\n", current_map, created_pics, cached_pics, pics_allocated);
        }
        if ((map_limit != -1) && (current_map == map_limit))
        {
            printf(" --- map limit reached, stopping ---\n");
            break;
        }
    }

    printf(" finished map parsing, %d maps processed, %d map pictures created, %d map pictures were uptodate. Total %d faces used.\n", current_map, created_pics, cached_pics, pics_allocated);

    if (list_unused_maps)
        dump_unused_maps();

    do_maps_index_by_region();
    do_region_index();
    do_maps_index();
    do_world_map();
    write_world_info();

    write_regions_link();
    write_slaying_info();

    return 0;
}


/**
 * Dummy functions to link the library.
 */

void draw_ext_info(int flags, int pri, const object *pl, uint8 type, uint8 subtype, const char *txt, const char *txt2)
{
    fprintf(logfile, "%s\n", txt);
}

void draw_ext_info_format(
        int flags, int pri, const object *pl, uint8 type,
        uint8 subtype,
        const char* new_format,
        const char* old_format,
        ...)
{
    va_list ap;
    va_start(ap, old_format);
    vfprintf(logfile, old_format, ap);
    va_end(ap);
}


void ext_info_map(int color, const mapstruct *map, uint8 type, uint8 subtype, const char *str1, const char *str2)
{
    fprintf(logfile, "ext_info_map: %s\n", str2);
}

void move_teleporter( object* ob)
{
}

void move_firewall( object* ob)
{
}

void move_duplicator( object* ob)
{
}

void move_marker( object* ob)
{
}

void move_creator( object* ob)
{
}

void emergency_save( int x )
{
}

void clean_tmp_files( void )
{
}

void esrv_send_item( object* ob, object* obx )
{
}

void dragon_ability_gain( object* ob, int x, int y )
{
}

void weather_effect(mapstruct *m)
{
}

void set_darkness_map( mapstruct* m)
{
}

method_ret ob_move_on(object* op, object* victim, object* originator)
{
    return METHOD_OK;
}

object* find_skill_by_number(object *who, int skillno)
{
    return NULL;
}

void esrv_del_item(player *pl, int tag)
{
}

void esrv_update_item(int flags, object *pl, object *op)
{
}

void esrv_update_spells(player *pl)
{
}

void monster_check_apply( object* ob, object* obt )
{
}

void trap_adjust( object* ob, int x )
{
}

int execute_event(object* op, int eventcode, object* activator, object* third, const char* message, int fix)
{
    return 0;
}

int execute_global_event(int eventcode, ...)
{
    return 0;
}


int auto_apply (object *op) {
    object *tmp = NULL, *tmp2;
    int i;

    switch(op->type) {
        case SHOP_FLOOR:
            if (!HAS_RANDOM_ITEMS(op)) return 0;
            do {
                i=10; /* let's give it 10 tries */
                while((tmp=generate_treasure(op->randomitems,
                       op->stats.exp?(int)op->stats.exp:MAX(op->map->difficulty, 5)))==NULL&&--i);
                if(tmp==NULL)
                    return 0;
                if(QUERY_FLAG(tmp, FLAG_CURSED) || QUERY_FLAG(tmp, FLAG_DAMNED)) {
                    free_object(tmp);
                    tmp = NULL;
                }
            } while(!tmp);
            tmp->x=op->x;
            tmp->y=op->y;
            SET_FLAG(tmp,FLAG_UNPAID);
            insert_ob_in_map(tmp,op->map,NULL,0);
            CLEAR_FLAG(op,FLAG_AUTO_APPLY);
            identify(tmp);
            break;

        case TREASURE:
            if (QUERY_FLAG(op,FLAG_IS_A_TEMPLATE))
                return 0;
            while ((op->stats.hp--)>0)
                create_treasure(op->randomitems, op, op->map?GT_ENVIRONMENT:0,
                op->stats.exp ? (int)op->stats.exp :
                        op->map == NULL ?  14: op->map->difficulty,0);

        /* If we generated an object and put it in this object inventory,
            * move it to the parent object as the current object is about
            * to disappear.  An example of this item is the random_* stuff
            * that is put inside other objects.
        */
            for (tmp=op->inv; tmp; tmp=tmp2) {
                tmp2 = tmp->below;
                remove_ob(tmp);
                if (op->env) insert_ob_in_ob(tmp, op->env);
                else free_object(tmp);
            }
            remove_ob(op);
            free_object(op);
            break;
    }
    return tmp ? 1 : 0;
}

void fix_auto_apply(mapstruct * m)
{
}

void do_auto_apply(mapstruct * m)
{
    object *tmp,*above=NULL;
    int x,y;

    if(m==NULL) return;

    for(x=0;x<MAP_WIDTH(m);x++)
        for(y=0;y<MAP_HEIGHT(m);y++)
            for(tmp=get_map_ob(m,x,y);tmp!=NULL;tmp=above) {
        above=tmp->above;

        if (tmp->inv) {
            object *invtmp, *invnext;

            for (invtmp=tmp->inv; invtmp != NULL; invtmp = invnext) {
                invnext = invtmp->below;

                if(QUERY_FLAG(invtmp,FLAG_AUTO_APPLY))
                    auto_apply(invtmp);
                else if(invtmp->type==TREASURE && HAS_RANDOM_ITEMS(invtmp)) {
                    while ((invtmp->stats.hp--)>0)
                        create_treasure(invtmp->randomitems, invtmp, 0,
                                        m->difficulty,0);
                    invtmp->randomitems = NULL;
                }
                else if (invtmp && invtmp->arch &&
                         invtmp->type!=TREASURE &&
                         invtmp->type != SPELL &&
                         invtmp->type != CLASS &&
                         HAS_RANDOM_ITEMS(invtmp)) {
                    create_treasure(invtmp->randomitems, invtmp, 0,
                                    m->difficulty,0);
                /* Need to clear this so that we never try to create
                    * treasure again for this object
                */
                    invtmp->randomitems = NULL;
                         }
            }
            /* This is really temporary - the code at the bottom will
            * also set randomitems to null.  The problem is there are bunches
            * of maps/players already out there with items that have spells
            * which haven't had the randomitems set to null yet.
            * MSW 2004-05-13
            *
            * And if it's a spellbook, it's better to set randomitems to NULL too,
            * else you get two spells in the book ^_-
            * Ryo 2004-08-16
            */
            if (tmp->type == WAND || tmp->type == ROD || tmp->type == SCROLL ||
                tmp->type == HORN || tmp->type == FIREWALL || tmp->type == POTION ||
                tmp->type == ALTAR || tmp->type == SPELLBOOK)
                tmp->randomitems = NULL;

        }

        if(QUERY_FLAG(tmp,FLAG_AUTO_APPLY))
            auto_apply(tmp);
        else if((tmp->type==TREASURE || (tmp->type==CONTAINER))&& HAS_RANDOM_ITEMS(tmp)) {
            while ((tmp->stats.hp--)>0)
                create_treasure(tmp->randomitems, tmp, 0,
                                m->difficulty,0);
            tmp->randomitems = NULL;
        }
        else if(tmp->type==TIMED_GATE) {
            object *head = tmp->head != NULL ? tmp->head : tmp;
            if (QUERY_FLAG(head, FLAG_IS_LINKED)) {
                tmp->speed = 0;
                update_ob_speed(tmp);
            }
        }
        /* This function can be called everytime a map is loaded, even when
        * swapping back in.  As such, we don't want to create the treasure
        * over and ove again, so after we generate the treasure, blank out
        * randomitems so if it is swapped in again, it won't make anything.
        * This is a problem for the above objects, because they have counters
        * which say how many times to make the treasure.
        */
        else if(tmp && tmp->arch && tmp->type!=PLAYER && tmp->type!=TREASURE &&
                tmp->type != SPELL && tmp->type != PLAYER_CHANGER && tmp->type != CLASS &&
                HAS_RANDOM_ITEMS(tmp)) {
            create_treasure(tmp->randomitems, tmp, GT_APPLY,
                            m->difficulty,0);
            tmp->randomitems = NULL;
                }
            }

            for(x=0;x<MAP_WIDTH(m);x++)
                for(y=0;y<MAP_HEIGHT(m);y++)
                    for(tmp=get_map_ob(m,x,y);tmp!=NULL;tmp=tmp->above)
                        if (tmp->above &&
                            (tmp->type == TRIGGER_BUTTON || tmp->type == TRIGGER_PEDESTAL))
                            check_trigger (tmp, tmp->above);
}

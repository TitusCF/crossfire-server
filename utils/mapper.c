/*
    Crossfire map browser generator.

    Author: Nicolas Weeger <nicolas.weeger@laposte.net>, (C) 2006.

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
*/

/**
 * @file mapper.c
 * This program generates map browsing web pages.
 *
 * Quick run: without arguments, will make sensible choices.
 *
 * For help, try the -help option.
 *
 * The following information is generated:
 * - a page per map
 * - a page per region
 * - a global map index
 * - the world map, including regions information
 *
 * Since this program browses maps from the first map, only maps linked from there will be processed.
 *
 * Maps are generated as the server sees them, that is with weather effects, treasures instead of markers,
 * and things like that.
 *
 * For maps, 2 pictures are generated, one real size and one small-size.
 *
 * Three maps are generated for the world: raw world map, world map with region information, region information only.
 *
 * Maps are always sorted, by the map name (part after the last /).
 *
 * Files are generated based on templates, where tags are replaced by their runtime value.
 *
 * Templates are recursively included. Here is the list:
 * - map.template: main map template.
 *  - map_no_exit.template: template to use when no exit on the map.
 *  - map_with_exit.template: template to use when there are exits on the map.
 *   - map_exit.template: template to use for each exit on the map.
 * - region.template: region page template.
 *  - region_letter: template for one letter
 *   - region_map.template: one map in a region
 * - world.template: world map template
 *  - world_row.template: one row of world maps.
 *   - world_map.template: one map in the template.
 * - index.template: global map index.
 *  - index_letter.template: one letter in the index
 *   - index_map.template: one map in the whole index
 * - index_region.template: region index template.
 *  - index_region_region.template: one region in the index.
 *
 * Tags must be in the form #TAG#. To have a # in the code, please put ##. Valid tags are:
 *
 * - map:
 *  - NAME: map relative path
 *  - MAPPATH: full path to currently generated file.
 *  - MAPNAME: name of the map (part of the path after last /).
 *  - MAPPIC: name of full-size pic of the map.
 *  - MAPSMALLPIC: name of reduced-size pic of the map.
 *  - MAPEXIT: text generated by map_with_exit or map_no_exit.
 *  - INDEXPATH: path to index.html file.
 *  - REGIONPATH: path to region's file.
 *  - REGIONNAME: name of map's region.
 *  - REGIONINDEXPATH: path to region index file.
 *  - WORLDMAPPATH: path to world map file.
 * - map_no_exit:
 *  - tags for map, except MAPEXIT.
 * - map_with_exit:
 *  - tags for map, except MAPEXIT.
 *  - EXIT: text generated by the map exits.
 * - map_exit:
 *  - map's tags.
 *  - EXITNAME: name of exit (part of the path after /).
 *  - EXITPATH: relative path of exit's page.
 * - region:
 *  - MAPCOUNT: count of maps in region.
 *  - LETTERS: text generated by region_letter processing.
 * - region_letter:
 *  - region's tags, except LETTERS.
 *  - MAPNAME: name of the map (part of the path after last /).
 *  - MAPPATH: relative path of the map from the map's root.
 *  - MAPHTML: relative path of HTML file for map.
 * - region_map:
 *  - tags of region_letter.
 *  - MAPNAME: name of the map (part of the path after last /).
 *  - MAPPATH: relative path of the map from the map's root.
 *  - MAPHTML: relative path of HTML file for map.
 * - world:
 *  - MAPS: text generated by world_row processing.
 *  - WORLDMAP: path to world map picture, with regions information.
 *  - WORLDRAW: path to raw world map, without regions information.
 *  - WORLDREGIONS: path to world map picture containing only regions information.
 * - world_row:
 *  - MAPS: text generated by world_map processing.
 * - world_map:
 *  - MAPNAME: name of the map (part of the path after last /).
 *  - MAPPATH: relative path of the map's generated page.
 *  - MAPLEFT, MAPTOP, MAPRIGHT, MAPBOTTOM: coordinates (in pixels) of current map in full world map.
 * - index:
 *  - MAPCOUNT: count of maps.
 *  - LETTERS: text generated by index_letter processing.
 * - index_letter:
 *  - tags of index, except LETTERS.
 *  - MAPS: text generated by index_letter processing.
 *  - LETTER: letter being processed, uppercase.
 *  - LETTERCOUNT: number of maps for current letter.
 * - index_map:
 *  - tags of index_letter.
 *  - MAPNAME: name of the map (part of the path after last /).
 *  - MAPPATH: relative path of the map from the map's root.
 *  - MAPHTML: relative path of HTML file for map.
 * - index_region:
 *  - REGIONCOUNT: total number of regions.
 *  - REGIONS: text generated by index_region_region processing.
 * - index_region_region:
 *  - REGIONFILE: relative path to region page.
 *  - REGIONNAME: region name.
 */

#include <time.h>
#include <stdio.h>

#include <global.h>
#include <sproto.h>
#include <image.h>

#include <gd.h>
#include <gdfonts.h>
#include <gdfontl.h>
#include <gdfontg.h>

gdImagePtr* gdfaces;
extern int nrofpixmaps; /* Found in common/image.c */

/** Maps to process. */
const char** maps_list;
/** Count for ::maps_list. */
int maps_count;
/** Allocated item count for ::maps_list. */
int count_allocated;

/** Path to store generated files. Relative or absolute, shouldn't end with a / */
char root[500];
/** Number of created pictures for GD. */
int pics_allocated;

/* Options */
int generate_pics = 1;     /**< Whether to generate the picture or not. */
int force_pics = 0;        /**< To force picture regeneration even if map didn't change. */
int generate_index = 1;    /**< Whether to do the map index or not. */
int size_small = 16;       /**< Tile size for small map */
int map_limit = -1;        /**< Maximum number of maps to browse, -1 for all. */
int show_maps = 0;         /**< If set, will generate much information on map loaded. */

char* world_template;                 /**< World map template. */
char* world_row_template;             /**< One row in the world map. */
char* world_map_template;             /**< One map in a row. */

char* map_template;                 /**< Map template. */
char* map_no_exit_template;         /**< World map template: no exit. */
char* map_with_exit_template;       /**< Map template: exit template. */
char* map_exit_template;            /**< Map template: one exit. */

char* index_template;           /**< Index page template. */
char* index_letter;             /**< Index page template: one letter, including the maps it contains. */
char* index_map;                /**< Index page template: one map. */

char* region_template;          /**< Region page template. */
char* region_letter_template;   /**< One letter for the region. */
char* region_map_template;      /**< Region page template: one map. */

char* index_region_template;
char* index_region_region_template;

/** Picture statistics. */
int created_pics = 0; /**< Total created pics. */
int cached_pics = 0;  /**< Non recrated pics. */

/** Map output formats. */
enum output_format_type {
    OF_PNG = 0,     /**< PNG, default value. */
    OF_JPG = 1      /**< JPG. */
};

/** Extensions depending on output format. */
const char* output_extensions[] = { ".png", ".jpg" };

/** Selected output format. */
enum output_format_type output_format = OF_PNG;

/** Quality for jpg pictures. */
int jpeg_quality = -1;

/** Whether to generate raw pics or instancied ones. */
int rawmaps = 0;

typedef struct maps_in_region {
    const char* name;
    /** Maps in the region. */
    const char** maps_list;
    /** Count for maps_list. */
    int maps_count;
    /** Allocated item count for maps_list. */
    int count_allocated;
    /** Sum of locations, to compute name position. */
    int sum_x, sum_y, sum;
    /** If set, this region has at least one map part of the world, thus region name should be written. */
    int is_world;
} maps_in_region;

struct maps_in_region** regions = NULL;
int region_count = 0;
int region_allocated = 0;

void do_auto_apply(mapstruct * m);

/**
 * Concatenates a string, and free concatenated string.
 *
 * @param source
 * string to append to. Can be NULL.
 * @param add
 * string that is appened. Will be free()d after. Must not be NULL.
 * @return
 * new string that should be free()d by caller.
 */
static char* cat_template(char* source, char* add) {
    if (!source)
        return add;
    source = realloc(source, strlen(source) + strlen(add) + 1);
    strcat(source, add);
    free(add);
    return source;
}

/**
 * Reads a file in memory.
 *
 * @param name
 * file path to read.
 * @param buffer
 * where to store. Can be left uninitialized in case of errors.
 * @return
 * 1 if error, 0 else.
 */
static int read_template(const char* name, char** buffer) {
    FILE* file;
    size_t size;
    struct stat info;

    if (stat(name, &info)) {
        printf("Couldn't stat template %s!\n", name);
        return 1;
    }

    (*buffer) = calloc(1, info.st_size + 1);
    if (!(*buffer)) {
        printf("Template %s calloc failed!\n", name);
        return 1;
    }

    if (info.st_size == 0) {
        (*buffer)[0] = '\0';
        return 0;
    }

    file = fopen(name, "rb");
    if (!file) {
        printf("Couldn't open template %s!\n", name);
        free(*buffer);
        return 1;
    }
    if (fread(*buffer, info.st_size, 1, file) != 1) {
        printf("Couldn't read template %s!\n", name);
        free(*buffer);
        fclose(file);
        return 1;
    }
    fclose(file);
    return 0;
}

/**
 * Processes a template.
 *
 * Variables in the form #VARIABLE# will be substituted for specified values.
 *
 * @param template
 * template to process.
 * @param vars
 * variables to replace. Array must be NULL-terminated.
 * @param values
 * variables to replace by. Must be the same size as vars, no NULL element allowed.
 * @return
 * filled-in template, that must be free()d be caller. NULL if memory allocation error.
 *
 * @note
 * returned string will be a memory block larger than required, for performance reasons.
 */
static char* do_template(const char* template, const char** vars, const char** values) {
    int count = 0;
    const char* sharp = template;
    int maxlen = 0;
    int var = 0;
    char* result;
    char* current_result;
    const char* end;

    while ((sharp = strchr(sharp, '#')) != NULL) {
        sharp++;
        count++;
    }
    if (!count)
        return strdup(template);
    if (count % 2) {
        printf("Malformed template, mismatched #!\n");
        return strdup(template);
    }

    while (vars[var] != NULL) {
        if (strlen(values[var]) > maxlen)
            maxlen = strlen(values[var]);
        var++;
    }
    result = calloc(1, strlen(template) + maxlen * (count / 2) + 1);
    if (!result)
        return NULL;
    current_result = result;

    sharp = template;
    while ((sharp = strchr(sharp, '#')) != NULL) {
        end = strchr(sharp + 1, '#');
        strncpy(current_result, template, sharp - template);
        if (end == sharp+1) {
            strcat(current_result, "#");
        }
        else {
        current_result = current_result + strlen(current_result);
        var = 0;
        while (vars[var] != 0 && strncmp(vars[var], sharp + 1, end - sharp - 1))
            var++;
        if (vars[var] == 0)
            printf("Wrong tag: %s\n", sharp);
        else
            strcpy(current_result, values[var]);
        }
        current_result = current_result + strlen(current_result);
        sharp = end + 1;
        template = sharp;
    }
    strcat(current_result, template);
    return result;
}

/**
 * Computes the shortest path from one file to another.
 *
 * @param from
 * origin.
 * @param to
 * destination.
 * @param result
 * string that will contain the calculated path. Must be large enough, no test done.
 * @warning
 * from and to must be absolute paths (starting with /).
 */
static void relative_path(const char* from, const char* to, char* result)
{
    const char* fslash;
    const char* rslash;
    int dot = 0;

    result[0] = '\0';

    fslash = strchr(from + 1, '/');
    if (!fslash)
    {
        strcpy(result, to + 1);
        return;
    }

    rslash = strchr(to + 1, '/');
    while ( fslash && rslash && (fslash - from == rslash - to) && strncmp(from, to, fslash - from + 1) == 0)
    {
        from = fslash + 1;
        to = rslash + 1;
        fslash = strchr(fslash + 1, '/');
        rslash = strchr(rslash + 1, '/');
    }

    while (fslash)
    {
        strcat(result, "../");
        fslash = strchr(fslash + 1, '/');
    }
    if ( strlen( result ) && result[ strlen( result ) - 1 ] == '/' && *to == '/' )
        result[ strlen( result ) - 1 ] = '\0';
    strcat(result, to);
}

/**
 * Sorts the strings according to the last part of the filename (after the last /).
 *
 * @param left
 * first string.
 * @param right
 * second string.
 * @return
 * comparison on last element, and if equal then on whole string.
 */
static int sort_mapname( const void* left, const void* right )
{
    const char* l = *(const char**)left;
    const char* r = *(const char**)right;
    const char* sl = strrchr(l, '/');
    const char* sr = strrchr(r, '/');
    int c;

    if (!sl)
        sl = l;
    if (!sr)
        sr = r;
    c = strcasecmp(sl, sr);
    if (c)
        return c;

    return strcasecmp(l, r);
}

/**
 * Sorts an array of maps_in_region by region name.
 *
 * @param left
 * first region.
 * @param right
 * second region.
 * @return
 * result of strcmp() for names.
 */
static int sort_region( const void* left, const void* right )
{
    return strcmp((*((maps_in_region**)left))->name, (*((maps_in_region**)right))->name);
}

/**
 * Adds a map to specified array, if it isn't already.
 *
 * @param name
 * string to add.
 * @param maps
 * array to add to.
 * @param count
 * number of elements in the array.
 * @param allocated
 * maximum number of elements the array can contain before needind to be expanded.
 *
 * @note
 * will allocate memory and update variables when required.
 */
void add_map(const char* name, const char*** maps, int* count, int* allocated)
{
    int map;
    for (map = 0; map < *count; map++)
        if (strcmp(name, (*maps)[map]) == 0)
            return;

    if (*count == *allocated) {
        *allocated += 50;
        *maps = realloc(*maps, *allocated * sizeof(char*));
    }
    (*maps)[*count] = strdup(name);
    (*count)++;
}

/**
 * Links a map to a region.
 *
 * Will not readd the map if already linked.
 *
 * @param map
 * map name.
 * @param region
 * region name.
 */
void add_map_to_region(const char* map, const char* region) {
    int reg;
    int x, y;
    for (reg = 0; reg < region_count; reg++) {
        if (strcmp(regions[reg]->name, region) == 0)
            break;
    }
    if (reg == region_count) {
        if (reg == region_allocated) {
            region_allocated++;
            regions = realloc(regions, sizeof(maps_in_region*) * region_allocated);
            regions[reg] = calloc(1, sizeof(maps_in_region));
        }
        region_count++;
        regions[reg]->name = strdup(region);
    }
    add_map(map, &regions[reg]->maps_list, &regions[reg]->maps_count, &regions[reg]->count_allocated);
    if (sscanf(map, "/world/world_%d_%d",&x,&y) == 2) {
        regions[reg]->sum_x += (x-100);
        regions[reg]->sum_y += (y-100);
        regions[reg]->sum++;
        regions[reg]->is_world = 1;
    }
}

/**
 * Saves a map to a file, based on jpg/png settings.
 *
 * @param file
 * opened file to which to save.
 * @param pic
 * picture to save.
 */
static void save_picture(FILE* file, gdImagePtr pic) {
    if (output_format == OF_PNG)
        gdImagePng(pic, file);
    else
        gdImageJpeg(pic, file, jpeg_quality);
}

/**
 * Processes a map.
 *
 * Generates the .html file, the pictures (big and small).
 *
 * @param name
 * file to process. Must start with a /, relative to Crossfire map directory.
 */
void domap(const char* name)
{
    mapstruct* m = ready_map_name(name ,0);
    int x, y;
    object* item;
    gdImagePtr pic;
    gdImagePtr small;
    FILE* out;
    struct stat stats;
    struct stat statspic;
    char mapname[500];
    char exit_path[500];
    char* tmp;
    const char** exits = NULL;
    int exits_count = 0;
    int exits_allocated = 0;
    object* floor;
    char tmppath[MAX_BUF];

    char* exits_text;

    char htmlpath[500];         /* Map file path. */
    char mappic[500];           /* Name of map's full size picture. */
    char mapsmallpic[500];      /* Name of map's small size picture. */
    char mappicpath[500];       /* Path of map's full size picture. */
    char mapsmallpicpath[500];  /* Path of map's small size picture. */
    char indexpath[500];        /* Relative path of full index. */
    char regionpath[500];       /* Path to region's filename. */
    char regionname[500];       /* Name of map's region. */
    char regionindexpath[500];  /* Path to region index file. */
    char worldmappath[500];     /* Path to world map. */
    int needpic = 0;

    const char* vars[] = { "NAME", "MAPPATH", "MAPNAME", "MAPPIC", "MAPSMALLPIC", "MAPEXIT", "INDEXPATH", "REGIONPATH", "REGIONNAME", "REGIONINDEXPATH", "WORLDMAPPATH", NULL, NULL, NULL };
    const char* values[] = { name, htmlpath, mapname, mappic, mapsmallpic, "", indexpath, regionpath, regionname, regionindexpath, worldmappath, NULL, NULL, NULL };
    int vars_count = 0;
    while (vars[vars_count])
        vars_count++;

    add_map(name, &maps_list, &maps_count, &count_allocated);

    if (show_maps)
        printf(" processing map %s\n", name);

    if (!m) {
        printf("couldn't load map %s\n", name);
        return;
    }

    if (!rawmaps)
        do_auto_apply(m);

    add_map_to_region(m->path, get_name_of_region_for_map(m));

    relative_path(name, "/maps.html", indexpath);
    relative_path(name, "/world.html", worldmappath);
    relative_path(name, "/regions.html", regionindexpath);

    strcpy(regionname, get_name_of_region_for_map(m));
    strcpy(exit_path, "/");
    strcat(exit_path, regionname);
    strcat(exit_path, ".html");
    relative_path(name, exit_path, regionpath);

    tmp = strrchr(name, '/');
    strcpy(mapname, tmp + 1);
    strcpy(mappic, mapname);
    strcat(mappic, output_extensions[output_format]);
    strcpy(mapsmallpic, mapname);
    strcat(mapsmallpic, ".small");
    strcat(mapsmallpic, output_extensions[output_format]);

    strcpy(htmlpath, root);
    strncat(htmlpath, name, 500 - strlen(htmlpath));

    strcpy(mappicpath, htmlpath);
    strcat(mappicpath, output_extensions[output_format]);
    strcpy(mapsmallpicpath, htmlpath);
    strcat(mapsmallpicpath, ".small");
    strcat(mapsmallpicpath, output_extensions[output_format]);

    strcat(htmlpath, ".html");
    make_path_to_file(htmlpath);

    if (force_pics)
        needpic = 1;
    else if (generate_pics) {
        create_pathname(name, tmppath, MAX_BUF);
        stat(tmppath, &stats);
        if (stat(mappicpath, &statspic) || (statspic.st_mtime < stats.st_mtime))
            needpic = 1;
        else if (stat(mapsmallpicpath, &statspic) || (statspic.st_mtime < stats.st_mtime))
            needpic = 1;
    }
    else
        needpic = 0;

    if (needpic) {
        pic = gdImageCreateTrueColor( MAP_WIDTH(m) * 32, MAP_HEIGHT(m) * 32 );
        created_pics++;
    }
    else
        cached_pics++;

    for ( x = 0; x < 4; x++ )
        if ( m->tile_path[x] != NULL ) {
            memset(exit_path, 0, 500);
            strncpy(exit_path, path_combine_and_normalize(m->path, m->tile_path[x]), 500);
            create_pathname(exit_path, tmppath, MAX_BUF);
            if (stat(tmppath, &stats)) {
                printf("  map %s doesn't exist in map %s, for tile %d.\n", exit_path, name, x);
            }
            else
            {
                add_map(exit_path, &exits, &exits_count, &exits_allocated);
                add_map(exit_path, &maps_list, &maps_count, &count_allocated);
            }
        }

    for ( x = MAP_WIDTH(m) - 1; x >= 0; x-- )
        for ( y = MAP_HEIGHT(m) - 1; y >= 0 ; y-- ) {
            floor = GET_MAP_OB(m, x, y);
            if (!floor)
                continue;

            while (floor)
                floor = floor->above;
            while (floor && !QUERY_FLAG(floor, FLAG_IS_FLOOR))
                floor = floor->below;
            if (!floor)
                floor = GET_MAP_OB(m, x, y);

            for ( item = floor; item; item = item->above ) {
                if ((item->type == EXIT || item->type == TELEPORTER || item->type == PLAYER_CHANGER) && item->slaying) {
                    char ep[500];
                    const char* start;
                    memset(ep, 0, 500);
                    if (strcmp(item->slaying, "/!"))
                        strcpy(ep, EXIT_PATH(item));
                    else
                    {
                        if (!item->msg)
                        {
                            printf("  random map without message in %s at %d, %d\n", name, item->x, item->y);
                            continue;
                        }
                        /* Some maps have a 'exit_on_final_map' flag, ignore it. */
                        start = strstr(item->msg, "\nfinal_map ");
                        if (!start && strncmp(item->msg, "final_map", strlen("final_map")) == 0)
                            /* Message start is final_map, nice */
                            start = item->msg;
                        if (start)
                        {
                            char* end = strchr(start + 1, '\n');
                            start += strlen("final_map") + 2;
                            strncpy(ep, start, end - start);
                        }
                    }

                    if (strlen(ep)) {
                        strncpy(exit_path, path_combine_and_normalize(m->path, ep), 500);
                        create_pathname(exit_path, tmppath, MAX_BUF);
                        if (stat(tmppath, &stats)) {
                            printf("  map %s doesn't exist in map %s, at %d, %d.\n", ep, name, item->x, item->y);
                        }
                        else
                        {
                            add_map(exit_path, &exits, &exits_count, &exits_allocated);
                            add_map(exit_path, &maps_list, &maps_count, &count_allocated);
                        }
                    }
                }

                if (item->invisible)
                    continue;

                if (needpic) {
                    if (gdfaces[item->face->number] == NULL)
                    {
                        gdfaces[item->face->number] = gdImageCreateFromPngPtr(facesets[0].faces[item->face->number].datalen, facesets[0].faces[item->face->number].data);
                        pics_allocated++;
                    }
                    if (gdfaces[item->face->number] != 0 && !(item->head && item->face->number == item->head->face->number))
                    {
                        gdImageCopy(pic, gdfaces[item->face->number], x * 32, y * 32, 0, 0, gdfaces[item->face->number]->sx, gdfaces[item->face->number]->sy);
                    }
                }
            }
        }

    if (exits != NULL)
    {
        char* one_exit = NULL;
        int exit;
        char relative[500];
        char exitname[500];

        vars[vars_count] = "EXITNAME";
        vars[vars_count+1] = "EXITFILE";

        qsort(exits, exits_count, sizeof(const char*), sort_mapname);
        for (exit = 0; exit < exits_count; exit++)
        {
            relative_path(name, exits[exit], relative);
            tmp = strrchr(relative, '/');
            if (!tmp)
                strcpy(exitname, relative);
            else
                strcpy(exitname, tmp+1);
            strcat(relative, ".html");
            values[vars_count] = exitname;
            values[vars_count+1] = relative;
            one_exit = cat_template(one_exit, do_template(map_exit_template, vars, values));
            free(exits[exit]);
        }
        free(exits);
        vars[vars_count] = "EXIT";
        vars[vars_count+1] = NULL;
        values[vars_count] = one_exit;
        exits_text = do_template(map_with_exit_template, vars, values);
        free(one_exit);
    }
    else
        exits_text = do_template(map_no_exit_template, vars, values);

    values[5] = exits_text;
    vars[vars_count] = NULL;
    out = fopen(htmlpath, "w+");
    tmp = do_template(map_template, vars, values);
    fprintf(out, tmp);
    fclose(out);
    free(tmp);
    free(exits_text);

    if (needpic) {
        out = fopen(mappicpath, "wb+");
        save_picture(out, pic);
        fclose(out);

        small = gdImageCreateTrueColor( MAP_WIDTH(m) * size_small, MAP_HEIGHT(m) * size_small );
        gdImageCopyResampled(small, pic, 0, 0, 0, 0, MAP_WIDTH(m) * size_small, MAP_HEIGHT(m) * size_small, MAP_WIDTH(m) * 32, MAP_HEIGHT(m) * 32 );
        out = fopen(mapsmallpicpath, "wb+");
        save_picture(out, small);
        fclose(out);
        gdImageDestroy(small);

        gdImageDestroy(pic);
    }

    m->reset_time = 1;
    m->in_memory = MAP_IN_MEMORY;
    delete_map(m);
}

char* do_map_index(const char* dest, const char** maps_list, int maps_count, const char* template, const char* template_letter, const char* template_map, const char** vars, const char** values) {
#define VARSADD 6
    FILE* index;
    int map;
    char* string;
    char name[500];
    char mappath[500];
    char maphtml[500];
    char count[50];
    char lettercount[50];
    char* tmp;
    const char** idx_vars;
    const char** idx_values;
    char str_letter[2];
    char last_letter;
    char index_path[500];
    char* mapstext = NULL;
    int byletter;
    int basevalues;

    if (!generate_index)
        return;

    if (vars)
        for (basevalues = 0; vars[basevalues] != NULL; basevalues++) ;
    else
        basevalues = 0;

    idx_vars = malloc(sizeof(char*) * (basevalues+VARSADD));
    idx_vars[0] = "MAPCOUNT";
    memcpy(&idx_vars[1], vars, sizeof(char*) * basevalues);
    idx_vars[basevalues+VARSADD-1] = NULL;

    idx_values = malloc(sizeof(char*) * (basevalues+VARSADD-1));
    memcpy(&idx_values[1], values, sizeof(char*) * basevalues);

    string = NULL;

    sprintf(count, "%d", maps_count);
    idx_values[0] = count;

    idx_vars[basevalues+1] = "MAPNAME";
    idx_vars[basevalues+2] = "MAPPATH";
    idx_vars[basevalues+3] = "MAPHTML";
    idx_vars[basevalues+4] = NULL;

    qsort(maps_list, maps_count, sizeof(const char*), sort_mapname);

    last_letter = '\0';
    str_letter[0] = '\0';
    str_letter[1] = '\0';

    strcpy(index_path, "/");
    strcat(index_path, dest);

    string = NULL;
    for (map = 0; map < maps_count; map++ ) {
        tmp = strrchr(maps_list[map], '/');
        if (tmp)
            strcpy(name, tmp + 1);
        else {
            printf(" warning: map with no / in path: %s\n", maps_list[map]);
            strcpy(name, maps_list[map]);
        }
        if (tolower(name[0]) != last_letter) {
            if (mapstext != NULL) {
                idx_vars[basevalues+1] = "MAPS";
                idx_vars[basevalues+2] = "LETTER";
                idx_vars[basevalues+3] = "LETTERCOUNT";
                idx_vars[basevalues+4] = NULL;
                idx_values[basevalues+1] = mapstext;
                idx_values[basevalues+2] = str_letter;
                sprintf(lettercount, "%d", byletter);
                idx_values[basevalues+3] = lettercount;
                string = cat_template(string, do_template(template_letter, idx_vars, idx_values));
                free(mapstext);
                mapstext = NULL;
                idx_values[basevalues+2] = NULL;
            }
            last_letter = tolower(name[0]);
            str_letter[0] = last_letter;
            byletter = 0;
        }
        idx_vars[basevalues+1] = "MAPNAME";
        idx_vars[basevalues+2] = "MAPPATH";
        idx_vars[basevalues+3] = "MAPHTML";
        idx_values[basevalues+1] = name;
        relative_path(index_path, maps_list[map], mappath);
        strcpy(maphtml, mappath);
        strcat(maphtml, ".html");
        idx_values[basevalues+2] = mappath;
        idx_values[basevalues+3] = maphtml;
        mapstext = cat_template(mapstext, do_template(template_map, idx_vars, idx_values));
        byletter++;
    }
    if (last_letter != '\0') {
        idx_vars[basevalues+1] = "MAPS";
        idx_vars[basevalues+2] = "LETTER";
        idx_vars[basevalues+3] = "LETTERCOUNT";
        idx_vars[basevalues+4] = NULL;
        idx_values[basevalues+1] = mapstext;
        idx_values[basevalues+2] = str_letter;
        sprintf(lettercount, "%d", byletter);
        idx_values[basevalues+3] = lettercount;
        string = cat_template(string, do_template(template_letter, idx_vars, idx_values));
        free(mapstext);
        mapstext = NULL;
        idx_values[basevalues+2] = NULL;
    }

    idx_values[basevalues+1] = string;
    idx_vars[basevalues+1] = "LETTERS";
    idx_vars[basevalues+2] = NULL;
    tmp = do_template(template, idx_vars, idx_values);
    free(string);
    free(idx_vars);
    free(idx_values);
    return tmp;
}

/**
 * Generates the web page for a region.
 *
 * @param reg
 * region/maps for which to generate.
 *
 * @note
 * will sort the maps.
 */
void do_region(maps_in_region* reg) {
    char* string;
    FILE* index;
    char html[500];
    region* cfregion;

    const char* vars[] = { "REGIONNAME", "REGIONHTML", "REGIONLONGNAME", "REGIONDESC", NULL };
    const char* values[] = { reg->name, html, NULL, NULL };

    printf("Generating map index for region %s...", reg->name);

    cfregion = get_region_by_name(reg->name);
    if (cfregion) {
        values[2] = get_region_longname(cfregion);
        values[3] = get_region_msg(cfregion);
    }
    else {
        printf(" this isn't a real Crossfire region??");
        return;
    }

    strcpy(html, reg->name);
    strcat(html, ".html");

    string = do_map_index(html, reg->maps_list, reg->maps_count, region_template, region_letter_template, region_map_template, vars, values);

    strcpy(html, root);
    strcat(html, "/");
    strcat(html, reg->name);
    strcat(html, ".html");
    index = fopen(html, "w+");
    fprintf(index, string);
    fclose(index);
    free(string);

    printf(" done.\n");

}

/**
 * Generates all map indexes for a region.
 */
void do_maps_index_by_region() {
    int reg;

    qsort(regions, region_count, sizeof(maps_in_region*), sort_region);

    for (reg = 0; reg < region_count; reg++ )
        do_region(regions[reg]);
}

/**
 * Generates global map index, file maps.html.
 */
void do_maps_index() {
    char index_path[500];
    char* tmp;
    FILE* index;

    printf("Generating global map index in maps.html...");

    tmp = do_map_index("maps.html", maps_list, maps_count, index_template, index_letter, index_map, NULL, NULL);

    strcpy(index_path, root);
    strcat(index_path, "/maps.html");
    index = fopen(index_path, "w+");
    fprintf(index, tmp);
    fclose(index);
    free(tmp);

    printf(" done.\n");
}

/**
 * Generates region index.
 */
void do_region_index() {
    char* txt;
    char* final;
    char count[10];
    maps_in_region* region;
    int reg;
    char file[500];
    const char* vars[] = {"REGIONCOUNT", "REGIONFILE", "REGIONNAME", NULL};
    const char* values[] = {count, file, NULL};
    FILE* out;

    printf("Generating regions index in regions.html...");

    sprintf(count, "%d", region_count);
    txt = NULL;

    for (reg = 0; reg < region_count; reg++) {
        region = regions[reg];
        sprintf(file, "%s.html", region->name);
        values[2] = region->name;
        txt = cat_template(txt, do_template(index_region_region_template, vars, values));
    }
    vars[1] = "REGIONS";
    values[1] = txt;
    vars[2] = NULL;
    final = do_template(index_region_template, vars, values);
    free(txt);

    strcpy(file, root);
    strcat(file, "/regions.html");
    out = fopen(file, "w+");
    fprintf(out, final);
    fclose(out);
    free(final);

    printf(" done.\n");

}

/**
 * Generates a big world map.
 */
void do_world_map() {
#define SIZE 32
    int x, y;
    FILE* out;
    int wx, wy;
    char file[500];
    char* map = NULL;
    char* total;
    char* row = NULL;
    char mapleft[10], maptop[10], mapright[10], mapbottom[10];
    const char* vars[] = { NULL, NULL, "MAPLEFT", "MAPTOP", "MAPRIGHT", "MAPBOTTOM", NULL };
    const char* values[] = { NULL, NULL, mapleft, maptop, mapright, mapbottom, NULL };
    char name[100];
    char mappath[500], mapraw[500], mapregion[500];
    gdImagePtr pic;
    gdImagePtr small;
    int needpic;
    struct stat stats, statspic;
    int regenerated = 0;
    gdFontPtr font;
    int region, color;

    printf("Generating world map in world.html...");
    fflush(stdout);

    pic = gdImageCreateTrueColor(SIZE*30, SIZE*30);

    strcpy(file, root);
    strcat(file, "/world.html");

    wx = 100;
    wy = 100;

    for (y = 0; y < 30; y++) {
        for (x = 0; x < 30; x++) {
            values[0] = name;
            vars[0] = "MAPNAME";
            vars[1] = "MAPPATH";
            values[1] = mappath,
            sprintf(name, "world_%d_%d", wx, wy);
            sprintf(mappath, "world/%s.html", name);
            sprintf(mapleft, "%d", SIZE*x);
            sprintf(maptop, "%d", SIZE*y);
            sprintf(mapright, "%d", SIZE*(x+1)-1);
            sprintf(mapbottom, "%d", SIZE*(y+1)-1);

            map = cat_template(map, do_template(world_map_template, vars, values));

            sprintf(mappath, "%s/world/%s%s", root, name, output_extensions[output_format]);

            out = fopen(mappath, "rb");
            if (output_format == OF_PNG)
                small = gdImageCreateFromPng(out);
            else
                small = gdImageCreateFromJpeg(out);
            fclose(out);
            if (!small) {
                printf("\n  warning: pic not found for world_%d_%d", wx, wy);
                continue;
            }
            gdImageCopyResized(pic, small, SIZE*x, SIZE*y, 0, 0, SIZE, SIZE, small->sx, small->sy);
            gdImageDestroy(small);

            wx++;
        }
        wy++;
        wx = 100;
        values[0] = map;
        vars[0] = "MAPS";
        vars[1] = NULL;
        row = cat_template(row, do_template(world_row_template, vars, values));
        free(map);
        map = NULL;
    }
    sprintf(mappath, "world%s", output_extensions[output_format]);
    sprintf(mapraw, "world_raw%s", output_extensions[output_format]);
    sprintf(mapregion, "world_regions%s", output_extensions[output_format]);

    values[0] = row;
    vars[0] = "MAPS";
    values[1] = mappath;
    vars[1] = "WORLDMAP";
    values[2] = mapraw;
    vars[2] = "WORLDRAW";
    values[3] = mapregion;
    vars[3] = "WORLDREGIONS";
    vars[4] = NULL;
    total = do_template(world_template, vars, values);
    free(row);
    out = fopen(file, "w+");
    fprintf(out, total);
    free(total);
    fclose(out);

    sprintf(mappath, "%s/world_raw%s", root, output_extensions[output_format]);
    out = fopen(mappath, "wb+");
    save_picture(out, pic);
    fclose(out);

    /* Write region names. */
    small = gdImageCreateTrueColor(SIZE*30, SIZE*30);
    font = gdFontGetGiant();
    color = gdImageColorAllocateAlpha(pic, 255, 0, 0, 20);
    for (region = 0; region < region_allocated; region++) {
        if (!regions[region]->is_world || regions[region]->sum == 0)
            continue;

        x = regions[region]->sum_x * SIZE / regions[region]->sum + SIZE / 2 - strlen(regions[region]->name) * font->w / 2;
        y = regions[region]->sum_y * SIZE / regions[region]->sum + SIZE / 2 - font->h / 2;
        gdImageString(small, font, x, y, regions[region]->name, color);
        gdImageString(pic, font, x, y, regions[region]->name, color);
    }

    sprintf(mappath, "%s/world_regions%s", root, output_extensions[output_format]);
    out = fopen(mappath, "wb+");
    save_picture(out, small);
    fclose(out);
    gdImageDestroy(small);

    sprintf(mappath, "%s/world%s", root, output_extensions[output_format]);
    out = fopen(mappath, "wb+");
    save_picture(out, pic);
    fclose(out);
    gdImageDestroy(pic);

    printf(" done.\n");
#undef SIZE
}

/**
 * Prints usage information, and exit.
 *
 * @param program
 * program path.
 */
void do_help(const char* program) {
    printf("Crossfire Mapper will generate pictures of maps, and create indexes for all maps and regions.\n\n", program);
    printf("Syntax: %s\n\n", program);
    printf("Optional arguments:\n");
    printf("  -nopics             don't generate pictures.\n");
    printf("  -noindex            don't generate global map index.\n");
    printf("  -root=<path>        destination path. Default 'html'.\n");
    printf("  -limit=<number>     stop processing after this number of maps, -1 to do all maps (default).\n");
    printf("  -showmaps           outputs the name of maps as they are processed.\n");
    printf("  -jpg[=quality]      generate jpg pictures, instead of default png. Quality should be 0-95, -1 for automatic.\n");
    printf("  -forcepics          force to regenerate pics, even if pics's date is after map's.\n");
    printf("  -addmap=<map>       adds a map to process. Path is relative to map's directory root.\n");
    printf("  -rawmaps            generates maps pics without items on random (shop, treasure) tiles.\n");
    printf("\n\n");
    exit(0);
}

/**
 * Handles command-line parameters.
 *
 * @param argc
 * number of parameters, including program name.
 * @param argv
 * arguments, including program name.
 */
void do_parameters(int argc, char** argv) {
    int arg = 1;
    char path[500];

    root[0] = '\0';

    while (arg < argc) {
        if (strncmp(argv[arg], "-nopics", 7) == 0)
            generate_pics = 0;
        else if (strncmp(argv[arg], "-noindex", 8) == 0)
            generate_index = 0;
        else if (strncmp(argv[arg], "-root=", 6) == 0)
            strncpy(root, argv[arg] + 6, 500);
        else if (strncmp(argv[arg], "-limit=", 7) == 0)
            map_limit = atoi(argv[arg] + 7);
        else if (strncmp(argv[arg], "-showmaps", 9) == 0)
            show_maps = 1;
        else if (strncmp(argv[arg], "-jpg", 4) == 0) {
            output_format = OF_JPG;
            if (argv[arg][4] == '=') {
                jpeg_quality = atoi(argv[arg] + 5);
                if (jpeg_quality < 0)
                    jpeg_quality = -1;
            }
        }
        else if (strncmp(argv[arg], "-forcepics", 10) == 0)
            force_pics = 1;
        else if (strncmp(argv[arg], "-addmap=", 8) == 0) {
            if (*(argv[arg] + 8) == '/')
                strncpy(path, argv[arg] + 8, 500);
            else
                snprintf(path, 500, "/%s", argv[arg] + 8);
            add_map(path, &maps_list, &maps_count, &count_allocated);
        }
        else if (strncmp(argv[arg], "-rawmaps", 8) == 0)
            rawmaps = 1;
        else
            do_help(argv[0]);
        arg++;
    }
    if (!strlen(root))
        strcpy(root, "html");
    if (root[strlen(root) - 1] == '/')
        root[strlen(root) - 1] = '\0';
    if (map_limit < -1)
        map_limit = -1;
}

/**
 * Ensures destination directory exists.
 */
void create_destination() {
    char dummy[502];
    strcpy(dummy, root);
    strcat(dummy, "/a");
    make_path_to_file(dummy);
}

/**
 * Helper to write yes/no.
 *
 * @param value
 * value to print.
 * @return
 * "no" if value == 0, "yes" else.
 */
static const char* yesno(int value) {
    return (value ? "yes" : "no");
}

int main(int argc, char** argv)
{
    int current_map = 0;
    char max[50];

    maps_list = NULL;
    count_allocated = 0;
    pics_allocated = 0;
    maps_count = 0;

    do_parameters(argc, argv);

    printf("Initializing Crossfire data...\n");

    settings.debug = 0;

    init_globals();
    init_library();
    init_archetypes();
    init_artifacts();
    init_formulae();
    init_readable();
    init_regions();

    init_gods();
    read_client_images();

    printf("\n\n done.\n\n");

    create_destination();
    gdfaces = calloc(1, sizeof(gdImagePtr) * nrofpixmaps);

    if (read_template("templates/map.template", &map_template))
        return;
    if (read_template("templates/map_no_exit.template", &map_no_exit_template))
        return;
    if (read_template("templates/map_with_exit.template", &map_with_exit_template))
        return;
    if (read_template("templates/map_exit.template", &map_exit_template))
        return;

    if (read_template("templates/index.template", &index_template))
        return;
    if (read_template("templates/index_letter.template", &index_letter))
        return;
    if (read_template("templates/index_map.template", &index_map))
        return;

    if (read_template("templates/region.template", &region_template))
        return;
    if (read_template("templates/region_letter.template", &region_letter_template))
        return;
    if (read_template("templates/region_map.template", &region_map_template))
        return;

    if (read_template("templates/index_region.template", &index_region_template))
        return;
    if (read_template("templates/index_region_region.template", &index_region_region_template))
        return;

    if (read_template("templates/world.template", &world_template))
        return;
    if (read_template("templates/world_row.template", &world_row_template))
        return;
    if (read_template("templates/world_map.template", &world_map_template))
        return;

    if (map_limit != -1)
        sprintf(max, "%d", map_limit);
    else
        strcpy(max, "(none)");
    printf("Crossfire map browser generator\n");
    printf("-------------------------------\n\n");
    printf("Parameters:\n");
    printf("  path to write files:                 %s\n", root);
    printf("  maximum number of maps to process:   %s\n", max);
    printf("  will generate map picture:           %s\n", yesno(generate_pics));
    printf("  will always generate map picture:    %s\n", yesno(force_pics));
    printf("  picture output format:               %s\n", output_extensions[output_format]);
    if (output_format == OF_JPG)
        printf("  JPEG quality:                        %d\n", jpeg_quality);
    printf("  will generate map index:             %s\n", yesno(generate_index));
    printf("  show map being processed:            %s\n", yesno(show_maps));
    printf("  generate raw maps:                   %s\n", yesno(rawmaps));
    printf("\nbrowsing maps...\n");

    add_map(first_map_path, &maps_list, &maps_count, &count_allocated);

    while (current_map < maps_count)
    {
        domap(maps_list[current_map++]);
        if (current_map % 100 == 0)
        {
            printf(" %d maps processed, %d map pictures created, %d map pictures were uptodate. %d faces used.\n", current_map, created_pics, cached_pics, pics_allocated);
        }
        if ((map_limit != -1) && (current_map == map_limit))
        {
            printf(" --- map limit reached, stopping --- ");
            break;
        }
    }

    printf(" finished map parsing, %d maps processed, %d map pictures created, %d map pictures were uptodate. Total %d faces used.\n", current_map, created_pics, cached_pics, pics_allocated);

    do_maps_index_by_region();
    do_region_index();
    do_maps_index();
    do_world_map();

    return 0;
}


/**
 * Dummy functions to link the library.
 */

void draw_ext_info(int flags, int pri, const object *pl, uint8 type, uint8 subtype, const char *txt, const char *txt2)
{
    fprintf(logfile, "%s\n", txt);
}

void draw_ext_info_format(
        int flags, int pri, const object *pl, uint8 type, 
        uint8 subtype, 
        const char* new_format, 
        const char* old_format, 
        ...)
{
    va_list ap;
    va_start(ap, old_format);
    vfprintf(logfile, old_format, ap);
    va_end(ap);
}


void ext_info_map(int color, const mapstruct *map, uint8 type, uint8 subtype, const char *str1, const char *str2)
{
    fprintf(logfile, "ext_info_map: %s\n", str2);
}

void move_teleporter( object* ob)
{
}
 
void move_firewall( object* ob)
{
}
 
void move_duplicator( object* ob)
{
}
 
void move_marker( object* ob)
{
}
 
void move_creator( object* ob)
{
}
 
void emergency_save( int x )
{
}
 
void clean_tmp_files( void )
{
}
 
void esrv_send_item( object* ob, object* obx )
{
}
 
void dragon_ability_gain( object* ob, int x, int y )
{
}
 
void weather_effect( const char* c )
{
}
 
void set_darkness_map( mapstruct* m)
{
}
 
int ob_move_on(object* op, object* victim, object* originator)
{
}
 
object* find_skill_by_number( object* ob, int x )
{
    return NULL;
}
 
void esrv_del_item(player *pl, int tag)
{
}
 
void esrv_update_spells(player *pl)
{
}

void monster_check_apply( object* ob, object* obt )
{
}
 
void trap_adjust( object* ob, int x )
{
}

int execute_event(object* op, int eventcode, object* activator, object* third, const char* message, int fix)
{
    return 0;
}

int execute_global_event(int eventcode, ...)
{
    return 0;
}


int auto_apply (object *op) {
    object *tmp = NULL, *tmp2;
    int i;

    switch(op->type) {
        case SHOP_FLOOR:
            if (!HAS_RANDOM_ITEMS(op)) return 0;
            do {
                i=10; /* let's give it 10 tries */
                while((tmp=generate_treasure(op->randomitems,
                       op->stats.exp?(int)op->stats.exp:MAX(op->map->difficulty, 5)))==NULL&&--i);
                if(tmp==NULL)
                    return 0;
                if(QUERY_FLAG(tmp, FLAG_CURSED) || QUERY_FLAG(tmp, FLAG_DAMNED)) {
                    free_object(tmp);
                    tmp = NULL;
                }
            } while(!tmp);
            tmp->x=op->x;
            tmp->y=op->y;
            SET_FLAG(tmp,FLAG_UNPAID);
            insert_ob_in_map(tmp,op->map,NULL,0);
            CLEAR_FLAG(op,FLAG_AUTO_APPLY);
            identify(tmp);
            break;

        case TREASURE:
            if (QUERY_FLAG(op,FLAG_IS_A_TEMPLATE))
                return 0;
            while ((op->stats.hp--)>0)
                create_treasure(op->randomitems, op, op->map?GT_ENVIRONMENT:0,
                op->stats.exp ? (int)op->stats.exp : 
                        op->map == NULL ?  14: op->map->difficulty,0);

        /* If we generated an object and put it in this object inventory,
            * move it to the parent object as the current object is about
            * to disappear.  An example of this item is the random_* stuff
            * that is put inside other objects.
        */
            for (tmp=op->inv; tmp; tmp=tmp2) {
                tmp2 = tmp->below;
                remove_ob(tmp);
                if (op->env) insert_ob_in_ob(tmp, op->env);
                else free_object(tmp);
            }
            remove_ob(op);
            free_object(op);
            break;
    }
    return tmp ? 1 : 0;
}

void fix_auto_apply(mapstruct * m)
{
}

void do_auto_apply(mapstruct * m)
{
    object *tmp,*above=NULL;
    int x,y;

    if(m==NULL) return;

    for(x=0;x<MAP_WIDTH(m);x++)
        for(y=0;y<MAP_HEIGHT(m);y++)
            for(tmp=get_map_ob(m,x,y);tmp!=NULL;tmp=above) {
        above=tmp->above;

        if (tmp->inv) {
            object *invtmp, *invnext;

            for (invtmp=tmp->inv; invtmp != NULL; invtmp = invnext) {
                invnext = invtmp->below;

                if(QUERY_FLAG(invtmp,FLAG_AUTO_APPLY))
                    auto_apply(invtmp);
                else if(invtmp->type==TREASURE && HAS_RANDOM_ITEMS(invtmp)) {
                    while ((invtmp->stats.hp--)>0)
                        create_treasure(invtmp->randomitems, invtmp, 0,
                                        m->difficulty,0);
                    invtmp->randomitems = NULL;
                }
                else if (invtmp && invtmp->arch && 
                         invtmp->type!=TREASURE &&
                         invtmp->type != SPELL && 
                         invtmp->type != CLASS &&
                         HAS_RANDOM_ITEMS(invtmp)) {
                    create_treasure(invtmp->randomitems, invtmp, 0,
                                    m->difficulty,0);
                /* Need to clear this so that we never try to create 
                    * treasure again for this object
                */
                    invtmp->randomitems = NULL;
                         }
            }
            /* This is really temporary - the code at the bottom will
            * also set randomitems to null.  The problem is there are bunches
            * of maps/players already out there with items that have spells
            * which haven't had the randomitems set to null yet.
            * MSW 2004-05-13
            *
            * And if it's a spellbook, it's better to set randomitems to NULL too,
            * else you get two spells in the book ^_-
            * Ryo 2004-08-16
            */
            if (tmp->type == WAND || tmp->type == ROD || tmp->type == SCROLL ||
                tmp->type == HORN || tmp->type == FIREWALL || tmp->type == POTION ||
                tmp->type == ALTAR || tmp->type == SPELLBOOK)
                tmp->randomitems = NULL;

        }

        if(QUERY_FLAG(tmp,FLAG_AUTO_APPLY))
            auto_apply(tmp);
        else if((tmp->type==TREASURE || (tmp->type==CONTAINER))&& HAS_RANDOM_ITEMS(tmp)) {
            while ((tmp->stats.hp--)>0)
                create_treasure(tmp->randomitems, tmp, 0,
                                m->difficulty,0);
            tmp->randomitems = NULL;
        }
        else if(tmp->type==TIMED_GATE) {
            object *head = tmp->head != NULL ? tmp->head : tmp;
            if (QUERY_FLAG(head, FLAG_IS_LINKED)) {
                tmp->speed = 0;
                update_ob_speed(tmp);
            }
        }
        /* This function can be called everytime a map is loaded, even when
        * swapping back in.  As such, we don't want to create the treasure
        * over and ove again, so after we generate the treasure, blank out
        * randomitems so if it is swapped in again, it won't make anything.
        * This is a problem for the above objects, because they have counters
        * which say how many times to make the treasure.
        */
        else if(tmp && tmp->arch && tmp->type!=PLAYER && tmp->type!=TREASURE &&
                tmp->type != SPELL && tmp->type != PLAYER_CHANGER && tmp->type != CLASS &&
                HAS_RANDOM_ITEMS(tmp)) {
            create_treasure(tmp->randomitems, tmp, GT_APPLY,
                            m->difficulty,0);
            tmp->randomitems = NULL;
                }
            }

            for(x=0;x<MAP_WIDTH(m);x++)
                for(y=0;y<MAP_HEIGHT(m);y++)
                    for(tmp=get_map_ob(m,x,y);tmp!=NULL;tmp=tmp->above)
                        if (tmp->above &&
                            (tmp->type == TRIGGER_BUTTON || tmp->type == TRIGGER_PEDESTAL))
                            check_trigger (tmp, tmp->above);
}

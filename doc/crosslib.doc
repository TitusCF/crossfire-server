/*
 *   This file was automatically generated by version 1.6 of cextract.
 *   Manual editing not recommended.
 *
 *   Created: Fri Jul 23 09:17:43 1993
 */
#ifndef __CEXTRACT__
#if __STDC__

/*
 * Initialises the internal linked list of archetypes (read from file).
 * Then the global "empty_archetype" pointer is initialised.
 * Then the blocksview[] array is initialised.
 */
void init_archetypes ( void );

/*
 * Stores debug-information about how efficient the hashtable
 * used for archetypes has been in the static errmsg array.
 */
void arch_info ( object *op );

/*
 * Initialise the hashtable used by the archetypes.
 */
void clear_archetable ( void );

/*
 * An alternative way to init the hashtable which is slower, but _works_...
 */
void init_archetable ( void );

/*
 * Dumps an archetype to debug-level output.
 */
void dump_arch ( archetype *at );

/*
 * Dumps _all_ archetypes to debug-level output.
 * If you run crossfire with debug, and enter DM-mode, you can trigger
 * this with the O key.
 */
void dump_all_archetypes ( void );

/*
 * Allocates, initialises and returns the pointer to an archetype structure.
 */
archetype *get_archetype_struct ( void );

/*
 * Reads/parses the archetype-file, and copies into a linked list
 * of archetype-structures.
 */
void first_arch_pass ( FILE *fp );

/*
 * Reads the archetype file once more, and links all pointers between
 * archetypes.
 */
void second_arch_pass ( FILE *fp );

/*
 * First initialises the archtype hash-table (init_archetable()).
 * Reads and parses the archetype file (with the first and second-pass
 * functions).
 * Then initialises treasures by calling load_treasures().
 */
void load_archetypes ( void );

/*
 * Creates and returns a new object which is a copy of the given archetype.
 * This function returns NULL on failure.
 */
object *arch_to_object ( archetype *at );

/*
 * Creates an object.  This function is called by get_archetype()
 * if it fails to find the appropriate archetype.
 * Thus get_archetype() will be guaranteed to always return
 * an object, and never NULL.
 */
object *create_singularity ( char *name );

/*
 * Finds which archetype matches the given name, and returns a new
 * object containing a copy of the archetype.
 */
object *get_archetype ( char *name );

/*
 * Finds the first archetype matching the given type, and returns the
 * name of the object within the archetype.
 * TODO: Redo missile weapons to use direct archetype-pointers, since
 * that is the only thing left which uses this routine.
 * (This routine uses too much cpu)
 */
char *get_archename ( int t );

/*
 * Hash-function used by the arch-hashtable.
 */
unsigned long hasharch ( char *str );

/*
 * Finds, using the hashtable, which archetype matches the given name.
 * returns a pointer to the found archetype, otherwise NULL.
 */
archetype *find_archetype ( char *name );

/*
 * Adds an archetype to the hashtable.
 */
void add_arch ( archetype *at );

/*
 * Returns the first archetype using the given type.
 * Used in treasure-generation.
 */
archetype *type_to_archetype ( int type );

/*
 * Returns a new object copied from the first archetype matching
 * the given type.
 * Used in treasure-generation.
 */
object *clone_arch ( int type );

/*
 * member: make instance from class
 */
object *ObjectCreateArch ( archetype * at );

/*
 * Push the specified object.  This can affect other buttons/gates/handles
 * altars/pedestals/holes in the whole map.
 * Changed the routine to loop through _all_ objects.
 * Better hurry with that linked list...
 */
void push_button ( object *op );

/*
 * Updates everything connected with the button op.
 * After changing the state of a button, this function must be called
 * to make sure that all gates and other buttons connected to the
 * button reacts to the (eventual) change of state.
 */
void update_button ( object *op );

/*
 * Updates every button on the map (by calling update_button() for them).
 */
void update_buttons ( mapstruct *m );

void use_trigger ( object *op );

/* only one part objects */
void animate_turning ( object *op );

/*
 * check_altar checks if sacrifice was accepted and removes sacrificed
 * objects. If sacrifice was succeed return 1 else 0
 */
int check_altar ( object *altar );

/* 1 down and 0 up */
void trigger_move ( object *op, int state );

void check_trigger ( object *op );

void add_button_link ( object *button, mapstruct *map, int connected );

/*
 * Remove the object from the linked lists of buttons in the map.
 * This is only needed by editors.
 */
void remove_button_link ( object *op );

/*
 * Return the first objectlink in the objects linked to this one
 */
objectlink *get_button_links ( object *button );

/*
 * Made as a separate function to increase efficiency
 */
int get_button_value ( object *button );

/*
 * nex_exp() is an alternative way to calculate experience based
 * on the ability of a monster.
 * It's far from perfect, and doesn't consider everything which
 * can be considered, thus it's only used in debugging.
 */
int new_exp ( object *ob );

/*
 * Returns true if the monster specified has any innate abilities.
 */
int has_ability ( object *ob );

/*
 * Add a new friendly object to the linked list of friendly objects.
 * No checking to see if the object is already in the linked list is done.
 */
void add_friendly_object ( object *op );

/*
 * Removes the specified object from the linked list of friendly objects.
 */
void remove_friendly_object ( object *op );

/*
 * Dumps all friendly objects.  Invoked in DM-mode with the G key.
 */
void dump_friendly_objects ( void );

/*
 * Initialise all function-pointers to dummy-functions which will
 * do nothing and return nothing (of value at least).
 * Very healthy to do this when using the library, since
 * function pointers are being called throughout the library, without
 * being checked first.
 * init_library() calls this function.
 */
void init_function_pointers ( void );

/*
 * Specifies which function to call when there is an emergency save.
 */
void set_emergency_save ( void (*addr)(int) );

/*
 * Specifies which function to call to clean temporary files.
 */
void set_clean_tmp_files ( void (*addr)() );

/*
 * Specifies which function to call to fix auto-apply (objects which
 * applies themselves when their map is loaded).
 */
void set_fix_auto_apply ( void (*addr)(mapstruct *) );

/*
 * Specifies which function to call to remove an object in the
 * linked list of friendly objects.
 */
void set_remove_friendly_object ( void (*addr)(object *) );

/*
 * Specify which function to call to do some work in active
 * maps.  That function might get called if there are several players,
 * and one player is using too much cpu to either load a map, or to
 * load pixmaps.
 */
void set_process_active_maps ( void (*addr)(void) );

/*
 * Specify which function to call to recoordinate all buttons.
 */
void set_update_buttons ( void (*addr)(mapstruct *) );

/*
 * Specify which function to call to draw text to the window
 * of a player.
 */
void set_draw_info ( void (*addr)(object *, const char *) );

/*
 * Specify which function to call to update the text in the
 * stat-window of a player.
 */
void set_draw_stats ( void (*addr)(object *) );

/*
 * Specify which function to call to update the graphics in the
 * inventory-window of a player.
 */
void set_draw_inventory_faces ( void (*addr)(object *) );

/*
 * Specify which function to call to update the graphics
 * in the look-window of a player.
 */
void set_draw_look_faces ( void (*addr)(object *) );

/*
 * Specify which function to call to update the content
 * in the inventory-window of a player.
 */
void set_draw_inventory ( void (*addr)(object *) );

/*
 * Specify which function to call to update the content
 * of the look-window of a player.
 */
void set_draw_look ( void (*addr)(object *) );

/*
 * Specify which function to call to apply an object.
 */
void set_apply ( int (*addr)(object *, object *) );

/*
 * Specify which function to call to draw on the graphic-window
 * of a player.
 */
void set_draw ( void (*addr)(object *) );

/*
 * Specify which function to call to check if a monster can
 * apply an object.
 */
void set_monster_check_apply ( object *(*addr)(object *, object *) );

/*
 * Specify which functino to call to initialise the blocksview[] array.
 */
void set_init_blocksview_players ( void (*addr)(void) );

void set_info_map ( void (*addr)(mapstruct *, char *) );

/*
 * fatal() is meant to be called whenever a fatal signal is intercepted.
 * It will call the emergency_save and the clean_tmp_files functions.
 */
void fatal ( int err );

/*
 * Dump to standard out the abilities of all monsters.
 */
void dump_abilities ( void );

/*
 * As dump_abilities(), but with an alternative way of output.
 */
void print_monsters ( void );

/*
 * Writes <num> ones and zeros to the given string based on the
 * <bits> variable.
 */
void bitstostring ( long bits, int num, char *str );

/*
 * It is vital that init_library() is called by any functions
 * using this library.
 * If you want to lessen the size of the program using the library,
 * you can replase the call to init_library() with init_globals(),
 * init_function_pointers() and init_defaults().
 * (This is done in the client)
 */
void init_library ( void );

/*
 * Initialises all global variables.
 * Might use environment-variables as default for some of them.
 */
void init_globals ( void );

/*
 * Sets up and initialises the linked list of free and used objects.
 * Allocates a certain chunk of objects and puts them on the free list.
 * Called by init_library();
 */
void init_objects ( void );

/*
 * Initialises global variables which can be changed by options.
 * Called by init_library().
 */
void init_defaults ( void );

/*
 * query_weight(object) returns a character pointer to a static buffer
 * containing the text-representation of the weight of the given object.
 * The buffer will be overwritten by the next call to query_weight().
 */
char *query_weight ( object *op );

/*
 * get_number(integer) returns the text-representation of the given number
 * in a static buffer.  The buffer might be overwritten at the next
 * call to get_number().
 * It is currently only used by the query_name() function.
 */
char *get_number ( int i );

/*
 * query_name(object) returns a character pointer pointing to a static
 * buffer which contains a verbose textual representation of the name
 * of the given object.  The buffer will be overwritten at the next
 * call to query_name().
 */
char *query_name ( object *op );

/*
 * Returns a pointer to a static buffer which contains a
 * description of the given object.
 * If it is a monster, lots of information about its abilities
 * will be returned.
 * If it is an item, lots of information about which abilities
 * will be gained about its user will be returned.
 * If it is a player, it writes out the current abilities
 * of the player, which is usually gained by the items applied.
 */
char *describe_item ( object *op );

int always_magical ( object *op );

int need_identify ( object *op );

/*
 * Supposed to fix face-values as well here, but later.
 */
void identify ( object *op );

/*
 * Allocates a new objectlink structure, initialises it, and returns
 * a pointer to it.
 */
objectlink *get_objectlink ( void );

/*
 * Allocates a new oblinkpt structure, initialises it, and returns
 * a pointer to it.
 */
oblinkpt *get_objectlinkpt ( void );

/*
 * Recursively frees all objectlinks
 */
void free_objectlink ( objectlink *ol );

/*
 * Recursively frees all linked list of objectlink pointers
 */
void free_objectlinkpt ( oblinkpt *obp );

/*
 * sets Str/Dex/con/Wis/Cha/Int in stats to value, depending on
 * what attr is (STR to INT).
 */
void set_attr_value ( living *stats, int attr, signed char value );

/*
 * Like set_attr_value(), but instead the value (which can be negative)
 * is added to the specified stat.
 */
void change_attr_value ( living *stats, int attr, signed char value );

/*
 * returns the specified stat.  See also set_attr_value().
 */
signed char get_attr_value ( living *stats, int attr );

/*
 * Ensures that all stats (str/dex/con/wis/cha/int) are within the stat limit.
 */
void check_stat_bounds ( object *op );

/*
 * Adds abilities to the first object based on what the second object
 * gives to appliers.  If the second object does not have the APPLIED
 * flag set, it is assumed that it is being unapplied, and any abilities
 * it gives are subtracted from the first object.
 * (This is of course a problem now, since several objects may give
 * the same abilities, thus change_abil() is used mostly to display
 * messages, while fix_player() is called afterwards.)
 * Also writes a more or less informative message to the first object
 * about what abilities were gained/lost.
 */
int change_abil ( object *op, object *tmp );

/*
 * Stat draining by Vick 930307
 * (Feeling evil, I made it work as well now.  -Frank 8)
 */
void drain_stat ( object *op );

void drain_specific_stat ( object *op, int deplete_stats );

/*
 * A value of 0 indicates timeout, otherwise change the luck of the object.
 * via an applied bad_luck object.
 */
void change_luck ( object *op, int value );

/*
 * Subtracts stat-bonuses given by the class which the player has chosen.
 */
void remove_statbonus ( object *op );

/*
 * Adds stat-bonuses given by the class which the player has chosen.
 */
void add_statbonus ( object *op );

/*
 * Updates all abilities given by applied objects in the inventory
 * of the given object.  Note: This function works for both monsters
 * and players; the "player" in the name is purely an archaic inheritance.
 */
void fix_player ( object *op );

/*
 * Returnes true if the given player is a legal class.
 * The function to add and remove class-bonuses to the stats doesn't
 * check if the stat becomes negative, thus this function
 * merely checks that all stats are 1 or more, and returns
 * false otherwise.
 */
int allowed_class ( object *op );

/*
 * Returns how much experience is needed for a player to become
 * the given level.
 */
int level_exp ( int level );

/*
 * Adds (or subtracts) experience to a living object.  If it is a player,
 * checks for level-gain/loss is done.
 * The routines for gaining/losing levels is also within this function.
 */
void add_exp ( object *op, int exp );

/*
 * Initialises the array of variable-names.  Needed before any
 * objects can be loaded.  Called by init_library().
 */
void init_vars ( void );

/*
 * Searches through all possible variables to find any that matches
 * the given string.  An index to the variable_const[] array is returned,
 * or -1 on failure.
 */
int get_variable ( char *name );

/*
 * Returns a pointer to a static string which contains all variables
 * which are different in the two given objects.
 */
char *get_ob_diff ( object *op, object *op2 );

/*
 * Dumps all variables in an object to a file.
 * If big 0 of flag is set, do a raw save without any checks.
 * If bit 1 of flag is set, don't remove the object after save.
 */
void save_object ( FILE *fp, object *op, int flag );

/*
 * Returns true if the given color exists in the internal list
 * of legal colors.
 */
char find_color ( char *name );

/*
 * set_variable() expects buf to be a line with two arguments, the first
 * being a variable and the second being the value (which can be anything from
 * an integer to a string). 
 * The object given will have the given variable modified.
 *
 * -1 will be returned if there is no such variable
 * 0 will be returned if the variable is to be ignored
 * 1 will be returned if the variable was "anim"
 * 2 will be returned if the variable was "end"
 * 3 will be returned if the variable was "Inventory"
 * 4 will be returned if the variable was "More"
 * 5 will be returned if the variable was "msg"
 * 6 will be returned if the variable was "endmsg"
 * otherwise 0 will be returned
 */
int set_variable ( object *op, char *buf );

/*
 * Loads an object from the given file-pointer.
 * Variables will be read and parsed and patched into the object
 * until the string "end" is reached, or the end of the file.
 * If EOF is reached, it returnes false, otherwise true.
 */
int load_object ( FILE *fp, object *op );

/*
 * Logs a message to stderr, or to file, and/or even to socket.
 * Or discards the message if it is of no importanse, and none have
 * asked to hear messages of that logLevel.
 * logLevels can be logError (always printed), llevDebug, and llevMonster.
 */
void LOG ( LogLevel logLevel, char *format, ... );

/*
 * Used to initialise the array used by the LOS routines.
 */
void set_block ( int x, int y, int bx, int by );

/*
 * initialises the array used by the LOS routines.
 */
void init_block ( void );

/*
 * Used to initialise the array used by the LOS routines.
 */
void set_wall ( object *op, int x, int y );

/*
 * Used to initialise the array used by the LOS routines.
 */
void check_wall ( object *op, int x, int y );

/*
 * Clears/initialises the los-array associated to the player
 * controlling the object.
 */
void clear_los ( object *op );

/*
 * expand_sight goes through the array of what the given player is
 * able to see, and expands the visible area a bit, so the player will,
 * to a certain degree, be able to see into corners.
 * This is somewhat suboptimal, would be better to improve the formula.
 * There are two versions of this function, based on wheter or not
 * CD_LINE_OF_SIGHT is defined.  If it is defined, the function
 * becomes a bit more time-consuming, but covers a few more "corners"...
 */
void expand_sight ( object *op );

/*
 * update_los() recalculates the array which specifies what is
 * visible for the given player-object.
 */
void update_los ( object *op );

/*
 * This function makes sure that update_los() will be called for all
 * players on the given map within the next frame.
 * It is triggered by removal or inserting of objects which blocks
 * the sight in the map.
 */
void update_all_los ( mapstruct *map );

/*
 * Debug-routine which dumps the array which specifies the visible
 * area of a player.  Triggered by the z key in DM mode.
 */
void print_los ( object *op );

/*
 * check_face_range() is used from init_blocksview() to avoid
 * crashing the game due to buggy data in the archetype file.
 * Must maintain some sanity in this madness... 8)
 */
int check_face_range ( Fontindex face, char *name );

/*
 * init_blocksview() fills an array (blocksview[]) with information
 * about which characters/pixmaps are blocking views.
 * This doesn't handle all cases (dropping a coin on top of a mountain),
 * but it's much faster than checking all the objects for BLOCKS_VIEW().
 */
void init_blocksview ( void );

/*
 * make_sure_seen: The object is supposed to be visible through walls, thus
 * check if any players are nearby, and edit their LOS array.
 */
void make_sure_seen ( object *op );

/*
 * make_sure_not_seen: The object which is supposed to be visible through
 * walls has just been removed from the map, so update the los of any
 * players within its range
 */
void make_sure_not_seen ( object *op );

/*
 * returns a char-pointer to a static array, in which a representation
 * of the decimal number given will be stored.
 */
char *ltostr10 ( signed long n );

/*
 * A fast routine which appends the name and decimal number specified
 * to the given buffer.
 * Could be faster, though, if the strcat()s at the end could be changed
 * into alternate strcat which returned a pointer to the _end_, not the
 * start!
 */
void save_long ( char *buf, char *name, long n );

/*
 * Returns the mapstruct which has a name matching the given argument.
 */
mapstruct *has_been_loaded ( char *name );

/*
 * This makes a path absolute outside the world of Crossfire.
 * In other words, it prepends LIBDIR/MAPDIR/ to the given path
 * and returns the pointer to a static array containing the result.
 */
char *create_pathname ( char *name );

/*
 * This program checks if a file with the given path exists.
 * -1 is returned if it failes, otherwise the mode of the file
 * is returned.
 */
int check_path ( char *name );

/*
 * Prints out debug-information about a map.
 */
void dump_map ( mapstruct *m );

/*
 * Prints otu debug-information about all maps.
 */
void dump_all_maps ( void );

/*
 * Returns true if a wall is present in a given location.
 */
int wall ( mapstruct *m, int x, int y );

/*
 * Returns true if it's impossible to see through the given coordinate
 * in the given map.
 */
int blocks_view ( mapstruct *m, int x, int y );

/*
 * Returns true if the given coordinate in the given map blocks magic.
 */
int blocks_magic ( mapstruct *m, int x, int y );

/*
 * Returns true if the given coordinate in the given map blocks passage.
 */
int blocked ( mapstruct *m, int x, int y );

/*
 * Returns true if the given coordinate in the map where the given object
 * is, blocks the given object (which may be multi-part)
 */
int blocked_link ( object *ob, int x, int y );

/*
 * Eneq(@csd.uu.se): This is a new version of blocked, this one handles objects
 * that can be passed through by monsters with the CAN_PASS_THRU defined.
 */
int blocked_two ( object *op, int x, int y );

/*
 * Returns true if the given archetype can't fit in the given spot.
 */
int arch_blocked ( archetype *at, mapstruct *m, int x, int y );

/*
 * Returns true if the given archetype can't fit into the map at the
 * given spot (some part of it is outside the map-boundaries).
 */
int arch_out_of_map ( archetype *at, mapstruct *m, int x, int y );

/*
 * Goes through all objects in the given map, and does a sanity-check
 * on all pointers.
 */
void refresh_map ( mapstruct *m );

/*
 * open_and_uncompress() first searches for the original filename.
 * if it exist, then it opens it and returns the file-pointer.
 * if not, it does two things depending on the flag.  If the flag
 * is set, it tries to create the original file by uncompressing a .Z file.
 * If the flag is not set, it creates a temporarily file and uncompresses
 * the .Z file into that file.  The temporary file will be deleted in
 * close_and_delete().
 * (Note, the COMPRESS_SUFFIX is used instead of ".Z", thus it can easily
 * be changed in the config file.)
 */
FILE *open_and_uncompress ( char *name, int flag, int *compressed );

/*
 * See open_and_uncompress().
 */
void close_and_delete ( FILE *fp );

/*
 * Loads (ands parses) the objects into a given map from the specified
 * file pointer.
 * If block is true, the game will be blocked until all objects have
 * been loaded (this is needed to avoid certain critical regions).
 */
void load_objects ( mapstruct *m, FILE *fp, int block );

void save_objects ( mapstruct *m, FILE *fp );

/*
 * Opens the file "filename" and reads information about the map
 * from the given file, and stores it in a newly allocated
 * mapstruct.  A pointer to this structure is returned, or NULL on failure.
 * If block is true, it will block the game while reading the objects.
 */
mapstruct *load_original_map ( char *filename, int block );

/*
 * Loads a map, which has been loaded earlier, from file.
 */
void load_temporary_map ( mapstruct *m );

void queue_push ( object* m_ob );

object *queue_pop ( void );

/*
 * Saves a map to file.  If flag is set, it is saved into the same
 * file it was (originally) loaded from.  Otherwise a temporary
 * filename will be genarated, and the file will be stored there.
 * The temporary filename will be stored in the mapstructure.
 */
void new_save_map ( mapstruct *m, int flag );

/*
 * If any directories in the given path doesn't exist, they are created.
 */
void make_path_to_file ( char *filename );

/*
 * Used to fix an ancient bug in old maps.
 * Will soon be obsolete.
 */
void check_background ( mapstruct *m, int x, int y );

/*
 * Clears the arrays containing object-pointers and outlook of a map.
 */
void clear_map ( mapstruct *m );

/*
 * This function relinks all _pointers_ to the objects from
 * one map to another.
 * Note: You can _not_ free the objects in the original map
 * after this function has been called.
 * (What happened to this function? It no longer copies the pointers! -Frank)
 */
void copy_map ( mapstruct *m1, mapstruct *m2 );

/*
 * This function, like copy_map(), relinks all _pointers_ from
 * one map to the other map.
 */
void relink_objs_offset ( mapstruct *m1, mapstruct *m2, int dx, int dy );

/*
 * Remove and free all objects in the inventory of the given object.
 */
void clean_object ( object *op );

/*
 * Remove and free all objects in the given map.
 */
void free_all_objects ( mapstruct *m );

/*
 * This function moves all objects from one map to another.
 *
 * move_all_objects(): Only used from the editor(s?)
 * Yes. -Frank
 */
void move_all_objects ( mapstruct *m1, mapstruct *m2 );

/*
 * function: vanish mapstruct
 * m       : pointer to mapstruct, if NULL no action
 */
void delete_map ( mapstruct *m );

/*
 * Frees everything allocated by the given mapstructure.
 */
void free_map ( mapstruct *m, int flag );

/*
 * If there is a global message in the map where the given object is,
 * display the message to the object.
 */
void draw_map_message ( object *op );

/*
 * Allocates, initialises, and returns a pointer to a mapstruct.
 */
mapstruct *get_linked_map ( char *path );

/*
 * Allocates the arrays contained in a mapstruct.
 */
void allocate_map ( mapstruct *m );

/*
 * Creates an empty map of the given size, and returns a pointer to it.
 */
mapstruct *get_empty_map ( int sizex, int sizey );

/*
 * An obsolete function, replaced by ready_map_name().
 */
mapstruct *ready_map ( int level, int flag );

/*
 * Makes sure the given map is loaded and swapped in.
 * Returns a pointer to the given map.
 */
mapstruct *ready_map_name ( char *name, int flush );

void no_maps_file ( char *filename );

void find_first_level ( char *path );

char *find_map_name ( int level );

void update_map_name ( int level, char *name );

void set_map_reset_time ( mapstruct *map );

/*
 * This routine is supposed to find out which level the players should have
 * before visiting this map.  It is used to calculate which bonuses to put
 * on magic items.
 */
int calculate_difficulty ( mapstruct *m );

void clean_tmp_map ( mapstruct *m );

object * MapGetObjectZ ( mapstruct * emap, int x, int y, int z );

/*
 * member: copy by translate objects from source to target
 * target: -map
 * source: -map
 * dx    : positive translate to right
 * dy    : positive translate to down
 */
void MapMoveScroll ( mapstruct *target, mapstruct *source, int dx, int dy );

object * MapGetRealObject ( mapstruct * emap, int x, int y, int z );

int MapInsertObjectZ ( mapstruct *emap, object *o, int x, int y, int z );

int MapObjectOut ( mapstruct *target, object *obj, int x, int y );

/*
 * Eneq(@csd.uu.se): Since we can have items buried in a character we need
 * a better check
 */
object *is_player_inv ( object *op );

/*
 * Used by Crossedit?
 * The result of the dump is stored in the static global errmsg array.
 */
void dump_object2 ( object *op );

/*
 * Dumps an object.  Returns output in the static global errmsg array.
 */
void dump_object ( object *op );

/*
 * This is really verbose...Can be triggered by the P key while in DM mode.
 * All objects are dumped to stderr (or alternate logfile, if in server-mode)
 */
void dump_all_objects ( void );

/*
 * animate_object(object) updates the face-variable of an object.
 * If the object is the head of a multi-object, all objects are animated.
 * If the object has the IS_TURNING() flag, that is taken into consideration.
 */
void animate_object ( object *op );

/*
 * get_nearest_part(multi-object, object 2) returns the part of the
 * multi-object 1 which is closest to the second object.
 * If it's not a multi-object, it is returned.
 */
object *get_nearest_part ( object *op, object *pl );

/*
 * Returns the object which has the count-variable equal to the argument.
 */
object *find_object ( int i );

/*
 * Returns the first object which has a name equal to the argument.
 * Used only by the patch command, but not all that useful.
 * Enables features like "patch <name-of-other-player> food 999"
 */
object *find_object_name ( char *str );

/*
 * Returns the object which this object marks as being the owner.
 * A id-scheme is used to avoid pointing to objects which have been
 * freed and are now reused.  If this is detected, the owner is
 * set to NULL, and NULL is returned.
 * (This scheme should be changed to a refcount scheme in the future)
 */
object *get_owner ( object *op );

/*
 * Sets the owner of the first object to the second object.
 * Also checkpoints a backup id-scheme which detects freeing (and reusage)
 * of the owner object.
 * See also get_owner() and unset_owner().
 */
void set_owner ( object *op, object *owner );

/*
 * Resets vital variables in an object
 */
void reset_object ( object *op );

/*
 * clear_object() frees everything allocated by an object, and also
 * clears all variables and flags to default settings.
 */
void clear_object ( object *op );

/*
 * copy object first frees everything allocated by the second object,
 * and then copies the contends of the first object into the second
 * object, allocating what needs to be allocated.
 */
void copy_object ( object *op2, object *op );

/*
 * expand_objects() allocates more objects for the list of unused objects.
 * It is called from get_object() if the list unused list is empty.
 */
void expand_objects ( void );

/*
 * get_object() grabs an object from the list of unused objects, makes
 * sure it is initialised, and returns it.
 * If there are no free objects, expand_objects() is called to get more.
 */
object *get_object ( void );

/*
 * If an object with the IS_TURNABLE() flag needs to be turned due
 * to the closest player being on the other side, this function can
 * be called to update the face variable, _and_ how it looks on the map.
 */
void update_turn_face ( object *op );

/*
 * update_object() updates the array which represents the map.
 * It takes into account invisible objects (and represent squares covered
 * by invisible objects by whatever is below them (unless it's another
 * invisible object, etc...))
 * If the object being updated is beneath a player, the look-window
 * of that player is updated (this might be a suboptimal way of
 * updating that window, though, since update_object() is called _often_)
 */
void update_object ( object *op );

/*
 * free_object() frees everything allocated by an object, removes
 * it from the list of used objects, and puts it on the list of
 * free objects.  The IS_FREED() flag is set in the object.
 * The object must have been removed by remove_ob() first for
 * this function to succeed.
 */
void free_object ( object *ob );

/*
 * count_free() returns the number of objects on the list of free objects.
 */
int count_free ( void );

/*
 * count_used() returns the number of objects on the list of used objects.
 */
int count_used ( void );

/*
 * sub_weight() recursively (outwards) subtracts a number from the
 * weight of an object (and what is carried by it's environment(s)).
 */
void sub_weight ( object *op, signed long weight );

/* remove_ob(op):
 *   This function removes the object op from the linked list of objects
 *   which it is currently tied to.  When this function is done, the
 *   object will have no environment.  If the object previously had an
 *   environment, the x and y coordinates will be updated to
 *   the previous environment.
 *   Beware: This function is called from the editor as well!
 */
void remove_ob ( object *op );

/*
 * merge_ob(op,top):
 *
 * This function goes through all objects below and including top, and
 * merges op to the first matching object.
 * If top is NULL, it is calculated.
 * Returns true if it succeded in the merge.
 */
int merge_ob ( object *op, object *top );

/*
 * insert_ob_in_map(op, map):
 * This function inserts the object in the two-way linked list
 * which represents what is on a map.
 * The second argument specifies the map, and the x and y variables
 * in the object about to be inserted specifies the position.
 */
void insert_ob_in_map ( object *op, mapstruct *m );

/*
 * get_split_ob(ob,nr) splits up ob into two parts.  The part which
 * is returned contains nr objects, and the remaining parts contains
 * the rest (or is removed and freed if that number is 0).
 * On failure, NULL is returned, and the reason put into the
 * global static errmsg array.
 */
object *get_split_ob ( object *orig_ob, int nr );

/*
 * decrease_ob_nr(object, number) decreases a specified number from
 * the amount of an object.  If the amount reaches 0, the object
 * is subsequently removed and freed.
 */
void decrease_ob_nr ( object *op, int i );

/*
 * decrease_ob(object) works like decrease_ob_nr(object, 1).
 */
void decrease_ob ( object *op );

/*
 * add_weight(object, weight) adds the specified weight to an object,
 * and also updates how much the environment(s) is/are carrying.
 */
void add_weight ( object *op, signed long weight );

/*
 * insert_ob_in_ob(op,environment):
 *   This function inserts the object op in the linked list
 *   inside the object environment.  If environment is NULL,
 *   the object will be stacked at the map.
 *
 *
 * Eneq(@csd.uu.se): Altered insert_ob_in_ob to make things picked up enter 
 * the inventory at the last position or next to other objects of the same
 * type.
 * Frank: Now sorted by type, archetype and magic!
 */
void insert_ob_in_ob ( object *op, object *where );

/*
 * Checks if any objects which has the WALK_ON() (or FLY_ON() if the
 * object is flying) flag set, will be auto-applied by the insertion
 * of the object into the map (applying is instantly done).
 * Any speed-modification due to SLOW_MOVE() of other present objects
 * will affect the speed_left of the object.
 */
void check_walk_on ( object *op );

/*
 * present_arch(arch, map, x, y) searches for any objects with
 * a matching archetype at the given map and coordinates.
 * The first matching object is returned, or NULL if none.
 */
object *present_arch ( archetype *at, mapstruct *m, int x, int y );

/*
 * present(type, map, x, y) searches for any objects with
 * a matching type variable at the given map and coordinates.
 * The first matching object is returned, or NULL if none.
 */
object *present ( unsigned char type, mapstruct *m, int x, int y );

/*
 * present_in_ob(type, object) searches for any objects with
 * a matching type variable in the inventory of the given object.
 * The first matching object is returned, or NULL if none.
 */
object *present_in_ob ( unsigned char type, object *op );

/*
 * present_arch_in_ob(archetype, object) searches for any objects with
 * a matching archetype in the inventory of the given object.
 * The first matching object is returned, or NULL if none.
 */
object *present_arch_in_ob ( archetype *at, object *op );

/*
 * set_cheat(object) sets the cheat flag (WAS_WIZ) in the object and in
 * all it's inventory (recursively).
 * If checksums are used, a player will get set_cheat called for
 * him/her-self and all object carried by a call to this function.
 */
void set_cheat ( object *op );

/*
 * find_free_spot(archetype, map, x, y, start, stop) will search for
 * a spot at the given map and coordinates which will be able to contain
 * the given archetype.  start and stop specifies how many squares
 * to search (see the freearr_x/y[] definition).
 * It returns a random choice among the alternatives found.
 */
int find_free_spot ( archetype *at, mapstruct *m, int x, int y, int
                     start, int stop );

/*
 * find_first_free_spot(archetype, mapstruct, x, y) works like
 * find_free_spot(), but it will search max number of squares.
 * But it will return the first available spot, not a random choice.
 */
int find_first_free_spot ( archetype *at, mapstruct *m, int x, int y );

/*
 * find_dir(map, x, y, exclude) will search some close squares in the
 * given map at the given coordinates for live objects.
 * It will not considered the object given as exlude among possible
 * live objects.
 * It returns the direction toward the first/closest live object if finds
 * any, otherwise 0.
 */
int find_dir ( mapstruct *m, int x, int y, object *exclude );

/*
 * distance(object 1, object 2) will return the square of the
 * distance between the two given objects.
 */
int distance ( object *ob1, object *ob2 );

/*
 * find_dir_2(delta-x,delta-y) will return a direction in which
 * an object which has subtracted the x and y coordinates of another
 * object, needs to travel toward it.
 */
int find_dir_2 ( int x, int y );

/*
 * absdir(int): Returns a number between 1 and 8, which represent
 * the "absolute" direction of a number (it actually takes care of
 * "overflow" in previous calculations of a direction).
 */
int absdir ( int d );

/*
 * dirdiff(dir1, dir2) returns how many 45-degrees differences there is
 * between two directions (which are expected to be absolute (see absdir())
 */
int dirdiff ( int dir1, int dir2 );

/*
 * can_pick(picker, item): finds out if an object is possible to be
 * picked up by the picker.  Returnes 1 on success, otherwise 0.
 */
int can_pick ( object *who, object *item );

/*
 * create clone from object to another
 */
object *ObjectCreateClone ( object *asrc );

/*
 * Returns a newly allocated and initialised and correctly
 * linked player structure.
 */
player *get_player_ob ( void );

void free_player ( player *pl );

/* re-cmp - get regular expression match.
 * Return values: NULL - no match or error in regexp.
 *                pointer to beginning of matching string
 */
char * re_cmp ( char *str, char *regexp );

/*
 * Initialises the hash-table used by the shared string library.
 */
void init_hash_table ( void );

/*
 * Hashing-function used by the shared string library.
 */
int hashstr ( char *str );

/*
 * Allocates and initialises a new shared_string structure, containing
 * the string str.
 */
shared_string * new_shared_string ( char *str );

/*
 * Description:
 *      This will add 'str' to the hash table. If there's no entry for this
 *      string, a copy will be allocated, and a pointer to that is returned.
 * Return values:
 *      - pointer to string identical to str
 */
char * add_string ( char *str );

/*
 * Description:
 *      This will increase the refcount of the string str, which *must*
 *      have been returned from a previous add_string().
 * Return values:
 *      - str
 */
char * add_refcount ( char *str );

/*
 * Description:
 *      This will see if str is in the hash table, and return the address
 *      of that string if it exists.
 * Return values:
 *      - pointer to identical string or NULL
 */
char * find_string ( char *str );

void free_string ( char *str );

/*
 * Description:
 *      The routines will gather statistics if SS_STATISTICS is defined.
 *      A call to this function will cause the statistics to be dumped
 *      into an external string errmsg, which must be large.
 * Return values:
 *      None
 */
void ss_dump_statistics ( void );

/*
 * Description:
 *      If (what & SS_DUMP_TABLE) dump the contents of the hash table to
 *      stderr. If (what & SS_DUMP_TOTALS) return a string which
 *      says how many entries etc. there are in the table.
 * Return values:
 *      - a string or NULL
 */
char * ss_dump_table ( int what );

/*
 * Based on (n+1)^2 = n^2 + 2n + 1
 * given that	1^2 = 1, then
 *		2^2 = 1 + (2 + 1) = 1 + 3 = 4
 * 		3^2 = 4 + (4 + 1) = 4 + 5 = 1 + 3 + 5 = 9
 * 		4^2 = 9 + (6 + 1) = 9 + 7 = 1 + 3 + 5 + 7 = 16
 *		...
 * In other words, a square number can be express as the sum of the
 * series n^2 = 1 + 3 + ... + (2n-1)
 */
int isqrt ( int n );

/*
 * A replacement of strdup(), since it's not defined at some
 * unix variants.
 */
char *strdup_local ( char *str );

/*
 * A replacement of strtol() since it's not defined at
 * many unix systems.
 */
long strtol_local ( char *str, char **ptr, int base );

/*
 * Initialise all variables used in the timing routines. 
 */
void reset_sleep ( void );

void log_time ( long process_utime );

/*
 * enough_elapsed_time will return true if the time passed since
 * last tick is more than max-time.
 */
int enough_elapsed_time ( void );

/*
 * sleep_delta checks how much time has elapsed since last tick.
 * If it is less than max_time, the remaining time is slept with select().
 */
void sleep_delta ( void );

void set_max_time ( long t );

void time_info ( object *op );

long seconds ( void );

/*
 * Allocate and return the pointer to an empty treasurelist structure.
 */
treasurelist *get_empty_treasurelist ( void );

/*
 * Allocate and return the pointer to an empty treasure structure.
 */
treasure *get_empty_treasure ( void );

/*
 * Reads the lib/treasures file from disk, and parses the contents
 * into an internal treasure structure (very linked lists)
 */
treasure *load_treasure ( FILE *fp );

/*
 * Opens LIBDIR/treasure and reads all treasure-declarations from it.
 * Each treasure is parsed with the help of load_treasure().
 */
void load_treasures ( void );

/*
 * Searches for the given treasurelist in the globally linked list
 * of treasurelists which has been built by load_treasures().
 */
treasurelist *find_treasurelist ( char *name );

/*
 * Searches, with the help of find_treasurelist, for the given
 * treasurelist.  Returns the first of the treasures within
 * the linked list of treasures in the found list.
 * Returns NULL on failure.
 */
treasure *find_treasure ( char *name );

/*
 * Generates the objects specified by the given treasure.
 * It goes recursively through the rest of the linked list.
 * If there is a certain percental chance for a treasure to be generated,
 * this is taken into consideration.
 * The second argument specifies for which object the treasure is
 * being generated.
 * If flag isn't GT_ENVIRONMENT, monster_check_apply() is called.
 * If flag is GT_INVISIBLE, only invisible objects are generated (ie, only
 * abilities.  This is used by summon spells, thus no summoned monsters
 * start with equipment, but only their abilities).
 */
void create_treasure ( treasure *t, object *op, int flag, int difficulty );

/*
 * Based upon the specified difficulty and upon the difftomagic_list array,
 * a random magical bonus is returned.  This is used when determine
 * the magical bonus created on specific maps.
 */
int magic_from_difficulty ( int difficulty );

/*
 * Sets magical bonus in an object, and recalculates the effect on
 * the armour variable, and the effect on speed of armour.
 * This function doesn't work properly, should add use of archetypes
 * to make it truly absolute.
 */
void set_abs_magic ( object *op, int magic );

/*
 * Sets a random magical bonus in the given object based upon
 * the given difficulty, and the given max possible bonus.
 */
void set_magic ( int difficulty, object *op, int max_magic );

/*
 * Randomly adds one magical ability to the given object.
 */
void set_ring_bonus ( object *op, int bonus );

/*
 * get_magic(diff) will return a random number between 0 and 4.
 * diff can be any value above 2.  The higher the diff-variable, the
 * higher is the chance of returning a low number.
 * It is only used in fix_generated_treasure() to set bonuses on
 * rings and amulets.
 * Another scheme is used to calculate the magic of weapons and armours.
 */
int get_magic ( int diff );

/*
 * generate_treasure() creates an object based upon the given list of
 * objectnames (or new objectlists) and the given difficulty.
 * The lists are specified in the include/treasure.h file.
 * NULL is returned on failure.
 */
object *generate_treasure ( int list, int difficulty );

/*
 * fix_generated_item():  This is called after an item is generated, in
 * order to set it up right.  This produced magical bonuses, puts spells
 * into scrolls/books/wands, makes it unidentified, hides the value, etc.
 */
void fix_generated_item ( object *op, int difficulty, int max_magic );

/*
 * Used in artifact generation.  The bonuses of the first object
 * is modified by the bonuses of the second object.
 */
void add_abilities ( object *op, object *change );

/*
 * Gives some items special abilities, powers and curses
 */
void generate_artifact ( object *op );

/*
 * If the artifact-lists haven't been initialised already, a call
 * to this function will result in a call to read_artifacts()
 */
void init_artifacts ( void );

/*
 * For debugging purposes.  Dumps all tables.
 */
void dump_artifacts ( void );

/*
 * Builds up the lists of artifacts from the file in the libdir.
 */
void read_artifacts ( void );

/*
 * Converts between Fontindex and XChar2b types.
 */
XChar2b fontindex_to_XChar2b ( Fontindex s );

/*
 * read_bmaps(): When bitmaps are used instead of fonts, this function
 * does the actual reading of all the bitmap-files, and sets up the
 * player->bitmaps array.  It assumes the bitmap directory and the
 * bmaps file are found in the LIBDIR directory.
 */
void read_bmaps ( player *pl );

/*
 * This function adds the path to the fontpath of the given display.
 * It's mostly copied from the X11R5 distribution.
 */
void set_font_path ( Display *dpy, char *path );

/*
 * Checks if "crossfire" is present somewhere in the fontpath of
 * the given display.
 */
int check_font_path ( Display *dpy );

/*
 * Uses check_font_path() and set_font_path() to check and, if needed
 * fix the fontpath for a player.
 * If it fails, it sets the "use_pixmaps" flag in the player structure,
 * which will prompt the read_bmaps() function at a later time.
 */
int fixfontpath ( player *pl );

/*
 * allocate_colors() tries to get enough colors for the game-window.
 * If it fails, it tries to use a private colormap.
 * If that also fails, it switches mode to black/white.
 */
void allocate_colors ( player *p, Window w );

#endif /* __STDC__ */
#endif /* __CEXTRACT__ */
